//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.3.1.7705
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162

 
	using System;
	using CompilerProject.GrammarElements;
    using CompilerProject.GrammarElements;


using System.Collections.Generic;
using Antlr.Runtime;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  MiniJavaSyntax 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.3.1.7705")]
[System.CLSCompliant(false)]
public partial class MiniJavaParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ASSIGN", "BLOCK_COMMENT", "BOOL", "BOOLEAN", "CLASS", "CLASSDECL", "CLASSVARDECL", "CLASSVARDECLLIST", "COMMA", "DIGIT", "DIV", "DOT", "DOUBLE", "ELIST", "ELSE", "EQUAL", "EXPONENT", "EXTENDS", "FALSE", "FLOAT", "FORMALLIST", "HIDDEN", "ID", "IF", "INT", "INTEGER", "LAND", "LBRACK", "LCURLY", "LENGTH", "LESS", "LESSEQ", "LETTER", "LINE_COMMENT", "LNOT", "LOR", "LPAREN", "MAIN", "MAINCLASSDECL", "METHODDECL", "METHODDECLLIST", "METHOD_CALL", "MINUS", "MORE", "MOREEQ", "NEQUAL", "NEW", "NULL", "PLUS", "PRINT", "PRINT2", "PROGRAM", "PUBLIC", "RBRACK", "RCURLY", "RETURN", "RPAREN", "SEMI", "SLIST", "STAR", "STATIC", "STMT", "STRING", "THIS", "TRUE", "TYPE", "UNARY_MINUS", "VARDECL", "VOID", "WHILE", "WHITESPACE"
	};
	public const int EOF=-1;
	public const int ASSIGN=4;
	public const int BLOCK_COMMENT=5;
	public const int BOOL=6;
	public const int BOOLEAN=7;
	public const int CLASS=8;
	public const int CLASSDECL=9;
	public const int CLASSVARDECL=10;
	public const int CLASSVARDECLLIST=11;
	public const int COMMA=12;
	public const int DIGIT=13;
	public const int DIV=14;
	public const int DOT=15;
	public const int DOUBLE=16;
	public const int ELIST=17;
	public const int ELSE=18;
	public const int EQUAL=19;
	public const int EXPONENT=20;
	public const int EXTENDS=21;
	public const int FALSE=22;
	public const int FLOAT=23;
	public const int FORMALLIST=24;
	public const int HIDDEN=25;
	public const int ID=26;
	public const int IF=27;
	public const int INT=28;
	public const int INTEGER=29;
	public const int LAND=30;
	public const int LBRACK=31;
	public const int LCURLY=32;
	public const int LENGTH=33;
	public const int LESS=34;
	public const int LESSEQ=35;
	public const int LETTER=36;
	public const int LINE_COMMENT=37;
	public const int LNOT=38;
	public const int LOR=39;
	public const int LPAREN=40;
	public const int MAIN=41;
	public const int MAINCLASSDECL=42;
	public const int METHODDECL=43;
	public const int METHODDECLLIST=44;
	public const int METHOD_CALL=45;
	public const int MINUS=46;
	public const int MORE=47;
	public const int MOREEQ=48;
	public const int NEQUAL=49;
	public const int NEW=50;
	public const int NULL=51;
	public const int PLUS=52;
	public const int PRINT=53;
	public const int PRINT2=54;
	public const int PROGRAM=55;
	public const int PUBLIC=56;
	public const int RBRACK=57;
	public const int RCURLY=58;
	public const int RETURN=59;
	public const int RPAREN=60;
	public const int SEMI=61;
	public const int SLIST=62;
	public const int STAR=63;
	public const int STATIC=64;
	public const int STMT=65;
	public const int STRING=66;
	public const int THIS=67;
	public const int TRUE=68;
	public const int TYPE=69;
	public const int UNARY_MINUS=70;
	public const int VARDECL=71;
	public const int VOID=72;
	public const int WHILE=73;
	public const int WHITESPACE=74;

	// delegates
	// delegators

	public MiniJavaParser( ITokenStream input )
		: this( input, new RecognizerSharedState() )
	{
	}
	public MiniJavaParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);

		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();


		OnCreated();
	}
		
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return MiniJavaParser.tokenNames; } }
	public override string GrammarFileName { get { return "D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g"; } }



		public ProgramStatement result;
		private bool flagDebug = false;
		
		///public const int HIDDEN = -10;
		public const int NONE = -1;
		
		//private List<BaseOperator> bufferTerm = new List<BaseOperator>();
		//private List<BaseOperator> bufferOperator = new List<BaseOperator>();
		
		List<RecognitionException> exceptions = new List<RecognitionException>();

		public override void ReportError(RecognitionException e)
		{
		    exceptions.Add(e);
		}
		
		public bool HasError
		{
			get { return exceptions.Count > 0; }
		}
		
		public string ErrorMessage
		{
			get { return this.GetErrorMessage(exceptions[0], this.TokenNames); }
		}
		
		public string ErrorPosition
		{
			get { return this.GetErrorHeader(exceptions[0]); }
		}



	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	public sealed partial class program_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public NonTerm value;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public program_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:80:1: public program returns [NonTerm value] : mainClass= mainClassDecl classes= classDeclList EOF ;
	[GrammarRule("program")]
	public MiniJavaParser.program_return program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		MiniJavaParser.program_return retval = new MiniJavaParser.program_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken EOF1 = default(IToken);
		MiniJavaParser.mainClassDecl_return mainClass = default(MiniJavaParser.mainClassDecl_return);
		MiniJavaParser.classDeclList_return classes = default(MiniJavaParser.classDeclList_return);

		CommonTree EOF1_tree = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(80, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:81:2: (mainClass= mainClassDecl classes= classDeclList EOF )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:82:3: mainClass= mainClassDecl classes= classDeclList EOF
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(82, 12);
			PushFollow(Follow._mainClassDecl_in_program163);
			mainClass=mainClassDecl();
			PopFollow();

			adaptor.AddChild(root_0, mainClass.Tree);
			DebugLocation(82, 34);
			PushFollow(Follow._classDeclList_in_program167);
			classes=classDeclList();
			PopFollow();

			adaptor.AddChild(root_0, classes.Tree);
			DebugLocation(82, 52);
			EOF1=(IToken)Match(input,EOF,Follow._EOF_in_program169); 
			DebugLocation(83, 3);
			 
						//#program = #(#[PROGRAM], #program); 
						List<BaseSymbol> symbols = new List<BaseSymbol>();
						//symbols.Add((BaseSymbol)(new NonTerm((NonTerm)mainClass.value)));
						symbols.Add(mainClass.value);
						symbols.AddRange(classes.valueList);
						//retval.value = new NonTerm(NonTermType.Program, symbols);
						//result = new ProgramStatement(mainClass.value, classes.valueList);
						retval.value = NonTermFactory.CreateProgramStatement(mainClass.value, classes.valueList);
						if (flagDebug) Console.WriteLine("program");
					

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(94, 1);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	private sealed partial class classDeclList_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public List<BaseSymbol> valueList;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public classDeclList_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_classDeclList();
	partial void LeaveRule_classDeclList();

	// $ANTLR start "classDeclList"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:96:1: classDeclList returns [ List<BaseSymbol> valueList ] : (classD= classDecl )* ;
	[GrammarRule("classDeclList")]
	private MiniJavaParser.classDeclList_return classDeclList()
	{
		EnterRule_classDeclList();
		EnterRule("classDeclList", 2);
		TraceIn("classDeclList", 2);
		MiniJavaParser.classDeclList_return retval = new MiniJavaParser.classDeclList_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		MiniJavaParser.classDecl_return classD = default(MiniJavaParser.classDecl_return);



				retval.valueList = new List<BaseSymbol>();
			
		try { DebugEnterRule(GrammarFileName, "classDeclList");
		DebugLocation(96, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:101:2: ( (classD= classDecl )* )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:102:3: (classD= classDecl )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(102, 3);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:102:3: (classD= classDecl )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==CLASS))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:102:5: classD= classDecl
					{
					DebugLocation(102, 11);
					PushFollow(Follow._classDecl_in_classDeclList204);
					classD=classDecl();
					PopFollow();

					adaptor.AddChild(root_0, classD.Tree);
					DebugLocation(103, 3);

								retval.valueList.Add(classD.value);
							

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(107, 3);
			 
						//#stmtList = #(#[SLIST], #stmtList); 
						/*if (classD != null)
						{
							retval.valueList.Add(classD.value);
						}*/
					

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classDeclList", 2);
			LeaveRule("classDeclList", 2);
			LeaveRule_classDeclList();
		}
		DebugLocation(114, 1);
		} finally { DebugExitRule(GrammarFileName, "classDeclList"); }
		return retval;

	}
	// $ANTLR end "classDeclList"

	private sealed partial class mainClassDecl_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public NonTerm value;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public mainClassDecl_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_mainClassDecl();
	partial void LeaveRule_mainClassDecl();

	// $ANTLR start "mainClassDecl"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:116:1: mainClassDecl returns [NonTerm value] : CLASS id= ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACK RBRACK ID RPAREN LCURLY statement= stmtList RCURLY RCURLY ;
	[GrammarRule("mainClassDecl")]
	private MiniJavaParser.mainClassDecl_return mainClassDecl()
	{
		EnterRule_mainClassDecl();
		EnterRule("mainClassDecl", 3);
		TraceIn("mainClassDecl", 3);
		MiniJavaParser.mainClassDecl_return retval = new MiniJavaParser.mainClassDecl_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken id = default(IToken);
		IToken CLASS2 = default(IToken);
		IToken LCURLY3 = default(IToken);
		IToken PUBLIC4 = default(IToken);
		IToken STATIC5 = default(IToken);
		IToken VOID6 = default(IToken);
		IToken MAIN7 = default(IToken);
		IToken LPAREN8 = default(IToken);
		IToken STRING9 = default(IToken);
		IToken LBRACK10 = default(IToken);
		IToken RBRACK11 = default(IToken);
		IToken ID12 = default(IToken);
		IToken RPAREN13 = default(IToken);
		IToken LCURLY14 = default(IToken);
		IToken RCURLY15 = default(IToken);
		IToken RCURLY16 = default(IToken);
		MiniJavaParser.stmtList_return statement = default(MiniJavaParser.stmtList_return);

		CommonTree id_tree = default(CommonTree);
		CommonTree CLASS2_tree = default(CommonTree);
		CommonTree LCURLY3_tree = default(CommonTree);
		CommonTree PUBLIC4_tree = default(CommonTree);
		CommonTree STATIC5_tree = default(CommonTree);
		CommonTree VOID6_tree = default(CommonTree);
		CommonTree MAIN7_tree = default(CommonTree);
		CommonTree LPAREN8_tree = default(CommonTree);
		CommonTree STRING9_tree = default(CommonTree);
		CommonTree LBRACK10_tree = default(CommonTree);
		CommonTree RBRACK11_tree = default(CommonTree);
		CommonTree ID12_tree = default(CommonTree);
		CommonTree RPAREN13_tree = default(CommonTree);
		CommonTree LCURLY14_tree = default(CommonTree);
		CommonTree RCURLY15_tree = default(CommonTree);
		CommonTree RCURLY16_tree = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "mainClassDecl");
		DebugLocation(116, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:117:2: ( CLASS id= ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACK RBRACK ID RPAREN LCURLY statement= stmtList RCURLY RCURLY )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:119:3: CLASS id= ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACK RBRACK ID RPAREN LCURLY statement= stmtList RCURLY RCURLY
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(119, 8);
			CLASS2=(IToken)Match(input,CLASS,Follow._CLASS_in_mainClassDecl240); 
			CLASS2_tree = (CommonTree)adaptor.Create(CLASS2);
			root_0 = (CommonTree)adaptor.BecomeRoot(CLASS2_tree, root_0);

			DebugLocation(119, 12);
			id=(IToken)Match(input,ID,Follow._ID_in_mainClassDecl245); 
			id_tree = (CommonTree)adaptor.Create(id);
			adaptor.AddChild(root_0, id_tree);

			DebugLocation(119, 22);
			LCURLY3=(IToken)Match(input,LCURLY,Follow._LCURLY_in_mainClassDecl247); 
			DebugLocation(120, 10);
			PUBLIC4=(IToken)Match(input,PUBLIC,Follow._PUBLIC_in_mainClassDecl253); 
			DebugLocation(120, 18);
			STATIC5=(IToken)Match(input,STATIC,Follow._STATIC_in_mainClassDecl256); 
			DebugLocation(120, 24);
			VOID6=(IToken)Match(input,VOID,Follow._VOID_in_mainClassDecl259); 
			DebugLocation(120, 30);
			MAIN7=(IToken)Match(input,MAIN,Follow._MAIN_in_mainClassDecl262); 
			DebugLocation(120, 38);
			LPAREN8=(IToken)Match(input,LPAREN,Follow._LPAREN_in_mainClassDecl265); 
			DebugLocation(121, 11);
			STRING9=(IToken)Match(input,STRING,Follow._STRING_in_mainClassDecl272); 
			DebugLocation(121, 19);
			LBRACK10=(IToken)Match(input,LBRACK,Follow._LBRACK_in_mainClassDecl275); 
			DebugLocation(121, 27);
			RBRACK11=(IToken)Match(input,RBRACK,Follow._RBRACK_in_mainClassDecl278); 
			DebugLocation(121, 29);
			ID12=(IToken)Match(input,ID,Follow._ID_in_mainClassDecl281); 
			ID12_tree = (CommonTree)adaptor.Create(ID12);
			adaptor.AddChild(root_0, ID12_tree);

			DebugLocation(122, 10);
			RPAREN13=(IToken)Match(input,RPAREN,Follow._RPAREN_in_mainClassDecl286); 
			DebugLocation(123, 10);
			LCURLY14=(IToken)Match(input,LCURLY,Follow._LCURLY_in_mainClassDecl292); 
			DebugLocation(123, 21);
			PushFollow(Follow._stmtList_in_mainClassDecl297);
			statement=stmtList();
			PopFollow();

			adaptor.AddChild(root_0, statement.Tree);
			DebugLocation(123, 37);
			RCURLY15=(IToken)Match(input,RCURLY,Follow._RCURLY_in_mainClassDecl299); 
			DebugLocation(124, 9);
			RCURLY16=(IToken)Match(input,RCURLY,Follow._RCURLY_in_mainClassDecl304); 
			DebugLocation(125, 3);
			 
						//#c.setType(MAINCLASSDECL); 
						//retval.value = new NonTerm(NonTermType.MainClass, statement.valueList);
						retval.value = NonTermFactory.CreateMainClassDecl(new Token(TokenType.ID, id.Text, id), statement.valueList);
						if (flagDebug) Console.WriteLine("mainClassDecl");
					

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("mainClassDecl", 3);
			LeaveRule("mainClassDecl", 3);
			LeaveRule_mainClassDecl();
		}
		DebugLocation(131, 1);
		} finally { DebugExitRule(GrammarFileName, "mainClassDecl"); }
		return retval;

	}
	// $ANTLR end "mainClassDecl"

	private sealed partial class stmtList_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public List<BaseSymbol> valueList;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public stmtList_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_stmtList();
	partial void LeaveRule_stmtList();

	// $ANTLR start "stmtList"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:133:1: stmtList returns [ List<BaseSymbol> valueList ] : (statement= stmt )* ;
	[GrammarRule("stmtList")]
	private MiniJavaParser.stmtList_return stmtList()
	{
		EnterRule_stmtList();
		EnterRule("stmtList", 4);
		TraceIn("stmtList", 4);
		MiniJavaParser.stmtList_return retval = new MiniJavaParser.stmtList_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		MiniJavaParser.stmt_return statement = default(MiniJavaParser.stmt_return);



				retval.valueList = new List<BaseSymbol>();
			
		try { DebugEnterRule(GrammarFileName, "stmtList");
		DebugLocation(133, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:138:2: ( (statement= stmt )* )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:139:3: (statement= stmt )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(139, 3);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:139:3: (statement= stmt )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==BOOLEAN||LA2_0==DOUBLE||(LA2_0>=ID && LA2_0<=INT)||LA2_0==LCURLY||(LA2_0>=PRINT && LA2_0<=PRINT2)||LA2_0==WHILE))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:139:5: statement= stmt
					{
					DebugLocation(139, 15);
					PushFollow(Follow._stmt_in_stmtList339);
					statement=stmt();
					PopFollow();

					adaptor.AddChild(root_0, statement.Tree);
					DebugLocation(140, 3);

								retval.valueList.Add(statement.value);
							

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(144, 3);
			 
						//#stmtList = #(#[SLIST], #stmtList); 
						/*if (statement != null)
						{
							retval.valueList.Add(statement.value);
						}*/
					

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stmtList", 4);
			LeaveRule("stmtList", 4);
			LeaveRule_stmtList();
		}
		DebugLocation(151, 1);
		} finally { DebugExitRule(GrammarFileName, "stmtList"); }
		return retval;

	}
	// $ANTLR end "stmtList"

	private sealed partial class classVarDeclList_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public List<BaseSymbol> valueList;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public classVarDeclList_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_classVarDeclList();
	partial void LeaveRule_classVarDeclList();

	// $ANTLR start "classVarDeclList"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:153:1: classVarDeclList returns [ List<BaseSymbol> valueList ] : (classVar= classVarDecl )* ;
	[GrammarRule("classVarDeclList")]
	private MiniJavaParser.classVarDeclList_return classVarDeclList()
	{
		EnterRule_classVarDeclList();
		EnterRule("classVarDeclList", 5);
		TraceIn("classVarDeclList", 5);
		MiniJavaParser.classVarDeclList_return retval = new MiniJavaParser.classVarDeclList_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		MiniJavaParser.classVarDecl_return classVar = default(MiniJavaParser.classVarDecl_return);



				retval.valueList = new List<BaseSymbol>();
			
		try { DebugEnterRule(GrammarFileName, "classVarDeclList");
		DebugLocation(153, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:158:2: ( (classVar= classVarDecl )* )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:159:3: (classVar= classVarDecl )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(159, 3);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:159:3: (classVar= classVarDecl )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if ((LA3_0==BOOLEAN||LA3_0==DOUBLE||LA3_0==ID||LA3_0==INT))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:159:5: classVar= classVarDecl
					{
					DebugLocation(159, 14);
					PushFollow(Follow._classVarDecl_in_classVarDeclList384);
					classVar=classVarDecl();
					PopFollow();

					adaptor.AddChild(root_0, classVar.Tree);
					DebugLocation(160, 3);
					 
								retval.valueList.Add(classVar.value); 
							

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classVarDeclList", 5);
			LeaveRule("classVarDeclList", 5);
			LeaveRule_classVarDeclList();
		}
		DebugLocation(172, 1);
		} finally { DebugExitRule(GrammarFileName, "classVarDeclList"); }
		return retval;

	}
	// $ANTLR end "classVarDeclList"

	private sealed partial class classVarDecl_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public NonTerm value;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public classVarDecl_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_classVarDecl();
	partial void LeaveRule_classVarDecl();

	// $ANTLR start "classVarDecl"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:174:1: classVarDecl returns [NonTerm value] : typeDecl= type id= ID SEMI ;
	[GrammarRule("classVarDecl")]
	private MiniJavaParser.classVarDecl_return classVarDecl()
	{
		EnterRule_classVarDecl();
		EnterRule("classVarDecl", 6);
		TraceIn("classVarDecl", 6);
		MiniJavaParser.classVarDecl_return retval = new MiniJavaParser.classVarDecl_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken id = default(IToken);
		IToken SEMI17 = default(IToken);
		MiniJavaParser.type_return typeDecl = default(MiniJavaParser.type_return);

		CommonTree id_tree = default(CommonTree);
		CommonTree SEMI17_tree = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "classVarDecl");
		DebugLocation(174, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:175:2: (typeDecl= type id= ID SEMI )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:176:3: typeDecl= type id= ID SEMI
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(176, 12);
			PushFollow(Follow._type_in_classVarDecl420);
			typeDecl=type();
			PopFollow();

			adaptor.AddChild(root_0, typeDecl.Tree);
			DebugLocation(176, 23);
			id=(IToken)Match(input,ID,Follow._ID_in_classVarDecl427); 
			id_tree = (CommonTree)adaptor.Create(id);
			adaptor.AddChild(root_0, id_tree);

			DebugLocation(176, 33);
			SEMI17=(IToken)Match(input,SEMI,Follow._SEMI_in_classVarDecl430); 
			DebugLocation(177, 3);

						//#classVarDecl = #(#[CLASSVARDECL], #classVarDecl); 
						///////////////////////retval.value = new NonTerm(NonTermType.ClassVarDecl, typeDecl.value, id.value);
						
						retval.value = NonTermFactory.CreateClassVarDecl(typeDecl.value, new Token(TokenType.ID, id.Text, id));
					

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classVarDecl", 6);
			LeaveRule("classVarDecl", 6);
			LeaveRule_classVarDecl();
		}
		DebugLocation(183, 1);
		} finally { DebugExitRule(GrammarFileName, "classVarDecl"); }
		return retval;

	}
	// $ANTLR end "classVarDecl"

	private sealed partial class extendsClause_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public NonTerm value;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public extendsClause_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_extendsClause();
	partial void LeaveRule_extendsClause();

	// $ANTLR start "extendsClause"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:185:1: extendsClause returns [NonTerm value] : ( EXTENDS id= ID |) ;
	[GrammarRule("extendsClause")]
	private MiniJavaParser.extendsClause_return extendsClause()
	{
		EnterRule_extendsClause();
		EnterRule("extendsClause", 7);
		TraceIn("extendsClause", 7);
		MiniJavaParser.extendsClause_return retval = new MiniJavaParser.extendsClause_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken id = default(IToken);
		IToken EXTENDS18 = default(IToken);

		CommonTree id_tree = default(CommonTree);
		CommonTree EXTENDS18_tree = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "extendsClause");
		DebugLocation(185, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:186:2: ( ( EXTENDS id= ID |) )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:187:3: ( EXTENDS id= ID |)
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(187, 3);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:187:3: ( EXTENDS id= ID |)
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==EXTENDS))
			{
				alt4 = 1;
			}
			else if ((LA4_0==LCURLY))
			{
				alt4 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:187:5: EXTENDS id= ID
				{
				DebugLocation(187, 12);
				EXTENDS18=(IToken)Match(input,EXTENDS,Follow._EXTENDS_in_extendsClause454); 
				DebugLocation(187, 17);
				id=(IToken)Match(input,ID,Follow._ID_in_extendsClause461); 
				id_tree = (CommonTree)adaptor.Create(id);
				adaptor.AddChild(root_0, id_tree);

				DebugLocation(188, 3);

							///////////           retval.value = new NonTerm(NonTermType.ExtendsClause, id.value);
							//retval.value = new NonTerm(NonTermType.ExtendsClause);
							retval.value = NonTermFactory.CreateExtendsClause(new Token(TokenType.ID, id.Text, id));
						

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:195:3: 
				{
				DebugLocation(195, 3);
				 
							//#extendsClause = #[NULL] 
							//retval.value = new NonTerm(NonTermType.ExtendsClause);
						

				}
				break;

			}
			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("extendsClause", 7);
			LeaveRule("extendsClause", 7);
			LeaveRule_extendsClause();
		}
		DebugLocation(200, 1);
		} finally { DebugExitRule(GrammarFileName, "extendsClause"); }
		return retval;

	}
	// $ANTLR end "extendsClause"

	private sealed partial class classDecl_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public NonTerm value;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public classDecl_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_classDecl();
	partial void LeaveRule_classDecl();

	// $ANTLR start "classDecl"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:202:1: classDecl returns [ NonTerm value ] : CLASS id= ID extends= extendsClause LCURLY classVars= classVarDeclList methods= methodDeclList RCURLY ;
	[GrammarRule("classDecl")]
	private MiniJavaParser.classDecl_return classDecl()
	{
		EnterRule_classDecl();
		EnterRule("classDecl", 8);
		TraceIn("classDecl", 8);
		MiniJavaParser.classDecl_return retval = new MiniJavaParser.classDecl_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken id = default(IToken);
		IToken CLASS19 = default(IToken);
		IToken LCURLY20 = default(IToken);
		IToken RCURLY21 = default(IToken);
		MiniJavaParser.extendsClause_return extends = default(MiniJavaParser.extendsClause_return);
		MiniJavaParser.classVarDeclList_return classVars = default(MiniJavaParser.classVarDeclList_return);
		MiniJavaParser.methodDeclList_return methods = default(MiniJavaParser.methodDeclList_return);

		CommonTree id_tree = default(CommonTree);
		CommonTree CLASS19_tree = default(CommonTree);
		CommonTree LCURLY20_tree = default(CommonTree);
		CommonTree RCURLY21_tree = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "classDecl");
		DebugLocation(202, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:203:2: ( CLASS id= ID extends= extendsClause LCURLY classVars= classVarDeclList methods= methodDeclList RCURLY )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:206:3: CLASS id= ID extends= extendsClause LCURLY classVars= classVarDeclList methods= methodDeclList RCURLY
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(206, 8);
			CLASS19=(IToken)Match(input,CLASS,Follow._CLASS_in_classDecl508); 
			CLASS19_tree = (CommonTree)adaptor.Create(CLASS19);
			root_0 = (CommonTree)adaptor.BecomeRoot(CLASS19_tree, root_0);

			DebugLocation(206, 14);
			id=(IToken)Match(input,ID,Follow._ID_in_classDecl516); 
			id_tree = (CommonTree)adaptor.Create(id);
			adaptor.AddChild(root_0, id_tree);

			DebugLocation(206, 28);
			PushFollow(Follow._extendsClause_in_classDecl523);
			extends=extendsClause();
			PopFollow();

			adaptor.AddChild(root_0, extends.Tree);
			DebugLocation(206, 50);
			LCURLY20=(IToken)Match(input,LCURLY,Follow._LCURLY_in_classDecl525); 
			DebugLocation(207, 14);
			PushFollow(Follow._classVarDeclList_in_classDecl535);
			classVars=classVarDeclList();
			PopFollow();

			adaptor.AddChild(root_0, classVars.Tree);
			DebugLocation(208, 12);
			PushFollow(Follow._methodDeclList_in_classDecl544);
			methods=methodDeclList();
			PopFollow();

			adaptor.AddChild(root_0, methods.Tree);
			DebugLocation(209, 9);
			RCURLY21=(IToken)Match(input,RCURLY,Follow._RCURLY_in_classDecl548); 
			DebugLocation(210, 3);
			 
						//#c.setType(CLASSDECL); 
						List<BaseSymbol> symbols = new List<BaseSymbol>() { };
						/*symbols.Add(id.value);
						symbols.Add(extends.value);
						symbols.AddRange(classVars.valueList);
						symbols.AddRange(methods.valueList);*/
						//retval.value = new NonTerm(NonTermType.Class, symbols);
						retval.value = NonTermFactory.CreateClassDecl(new Token(TokenType.ID, id.Text, id), extends.value, classVars.valueList, methods.valueList);
					

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classDecl", 8);
			LeaveRule("classDecl", 8);
			LeaveRule_classDecl();
		}
		DebugLocation(220, 1);
		} finally { DebugExitRule(GrammarFileName, "classDecl"); }
		return retval;

	}
	// $ANTLR end "classDecl"

	private sealed partial class methodDecl_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public NonTerm value;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public methodDecl_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_methodDecl();
	partial void LeaveRule_methodDecl();

	// $ANTLR start "methodDecl"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:223:1: methodDecl returns [ NonTerm value ] : PUBLIC typeDecl= type id= ID LPAREN formals= formalList RPAREN LCURLY statements= stmtList RETURN expression= expr SEMI RCURLY ;
	[GrammarRule("methodDecl")]
	private MiniJavaParser.methodDecl_return methodDecl()
	{
		EnterRule_methodDecl();
		EnterRule("methodDecl", 9);
		TraceIn("methodDecl", 9);
		MiniJavaParser.methodDecl_return retval = new MiniJavaParser.methodDecl_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken id = default(IToken);
		IToken PUBLIC22 = default(IToken);
		IToken LPAREN23 = default(IToken);
		IToken RPAREN24 = default(IToken);
		IToken LCURLY25 = default(IToken);
		IToken RETURN26 = default(IToken);
		IToken SEMI27 = default(IToken);
		IToken RCURLY28 = default(IToken);
		MiniJavaParser.type_return typeDecl = default(MiniJavaParser.type_return);
		MiniJavaParser.formalList_return formals = default(MiniJavaParser.formalList_return);
		MiniJavaParser.stmtList_return statements = default(MiniJavaParser.stmtList_return);
		MiniJavaParser.expr_return expression = default(MiniJavaParser.expr_return);

		CommonTree id_tree = default(CommonTree);
		CommonTree PUBLIC22_tree = default(CommonTree);
		CommonTree LPAREN23_tree = default(CommonTree);
		CommonTree RPAREN24_tree = default(CommonTree);
		CommonTree LCURLY25_tree = default(CommonTree);
		CommonTree RETURN26_tree = default(CommonTree);
		CommonTree SEMI27_tree = default(CommonTree);
		CommonTree RCURLY28_tree = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "methodDecl");
		DebugLocation(223, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:224:2: ( PUBLIC typeDecl= type id= ID LPAREN formals= formalList RPAREN LCURLY statements= stmtList RETURN expression= expr SEMI RCURLY )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:226:3: PUBLIC typeDecl= type id= ID LPAREN formals= formalList RPAREN LCURLY statements= stmtList RETURN expression= expr SEMI RCURLY
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(226, 9);
			PUBLIC22=(IToken)Match(input,PUBLIC,Follow._PUBLIC_in_methodDecl574); 
			PUBLIC22_tree = (CommonTree)adaptor.Create(PUBLIC22);
			root_0 = (CommonTree)adaptor.BecomeRoot(PUBLIC22_tree, root_0);

			DebugLocation(226, 20);
			PushFollow(Follow._type_in_methodDecl581);
			typeDecl=type();
			PopFollow();

			adaptor.AddChild(root_0, typeDecl.Tree);
			DebugLocation(226, 30);
			id=(IToken)Match(input,ID,Follow._ID_in_methodDecl587); 
			id_tree = (CommonTree)adaptor.Create(id);
			adaptor.AddChild(root_0, id_tree);

			DebugLocation(226, 41);
			LPAREN23=(IToken)Match(input,LPAREN,Follow._LPAREN_in_methodDecl589); 
			DebugLocation(226, 51);
			PushFollow(Follow._formalList_in_methodDecl596);
			formals=formalList();
			PopFollow();

			adaptor.AddChild(root_0, formals.Tree);
			DebugLocation(226, 70);
			RPAREN24=(IToken)Match(input,RPAREN,Follow._RPAREN_in_methodDecl598); 
			DebugLocation(226, 78);
			LCURLY25=(IToken)Match(input,LCURLY,Follow._LCURLY_in_methodDecl601); 
			DebugLocation(227, 15);
			PushFollow(Follow._stmtList_in_methodDecl611);
			statements=stmtList();
			PopFollow();

			adaptor.AddChild(root_0, statements.Tree);
			DebugLocation(228, 10);
			RETURN26=(IToken)Match(input,RETURN,Follow._RETURN_in_methodDecl616); 
			DebugLocation(228, 23);
			PushFollow(Follow._expr_in_methodDecl623);
			expression=expr();
			PopFollow();

			adaptor.AddChild(root_0, expression.Tree);
			DebugLocation(228, 34);
			SEMI27=(IToken)Match(input,SEMI,Follow._SEMI_in_methodDecl625); 
			DebugLocation(229, 9);
			RCURLY28=(IToken)Match(input,RCURLY,Follow._RCURLY_in_methodDecl630); 
			DebugLocation(230, 3);
			 
						//#md.setType(METHODDECL); 
						List<BaseSymbol> symbols = new List<BaseSymbol>() ;
						/*symbols.Add(typeDecl.value);
						symbols.Add(id.value);
						symbols.AddRange(formals.value);
						symbols.AddRange(statements.value);
						symbols.Add(expression.value);*/
						//retval.value = new NonTerm(NonTermType.Method, symbols);
						retval.value = NonTermFactory.CreateMethodDecl(typeDecl.value, new Token(TokenType.ID, id.Text, id), formals.valueList, statements.valueList, expression.value);
					

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("methodDecl", 9);
			LeaveRule("methodDecl", 9);
			LeaveRule_methodDecl();
		}
		DebugLocation(241, 1);
		} finally { DebugExitRule(GrammarFileName, "methodDecl"); }
		return retval;

	}
	// $ANTLR end "methodDecl"

	private sealed partial class methodDeclList_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public List<BaseSymbol> valueList;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public methodDeclList_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_methodDeclList();
	partial void LeaveRule_methodDeclList();

	// $ANTLR start "methodDeclList"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:242:1: methodDeclList returns [ List<BaseSymbol> valueList ] : (method= methodDecl )* ;
	[GrammarRule("methodDeclList")]
	private MiniJavaParser.methodDeclList_return methodDeclList()
	{
		EnterRule_methodDeclList();
		EnterRule("methodDeclList", 10);
		TraceIn("methodDeclList", 10);
		MiniJavaParser.methodDeclList_return retval = new MiniJavaParser.methodDeclList_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		MiniJavaParser.methodDecl_return method = default(MiniJavaParser.methodDecl_return);



				retval.valueList = new List<BaseSymbol>();
			
		try { DebugEnterRule(GrammarFileName, "methodDeclList");
		DebugLocation(242, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:247:2: ( (method= methodDecl )* )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:248:3: (method= methodDecl )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(248, 3);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:248:3: (method= methodDecl )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if ((LA5_0==PUBLIC))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:248:5: method= methodDecl
					{
					DebugLocation(248, 12);
					PushFollow(Follow._methodDecl_in_methodDeclList664);
					method=methodDecl();
					PopFollow();

					adaptor.AddChild(root_0, method.Tree);
					DebugLocation(249, 3);

								retval.valueList.Add(method.value);
							

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(253, 3);
			 
						//#methodDeclList = #(#[METHODDECLLIST], #methodDeclList); 
						/*if (method != null)
						{
							retval.valueList.Add(method.value);
						}*/
					

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("methodDeclList", 10);
			LeaveRule("methodDeclList", 10);
			LeaveRule_methodDeclList();
		}
		DebugLocation(260, 1);
		} finally { DebugExitRule(GrammarFileName, "methodDeclList"); }
		return retval;

	}
	// $ANTLR end "methodDeclList"

	private sealed partial class formalList_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public List<BaseSymbol> valueList;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public formalList_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_formalList();
	partial void LeaveRule_formalList();

	// $ANTLR start "formalList"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:263:1: formalList returns [ List<BaseSymbol> valueList ] : (formalDecl= formal ( COMMA formalDecl= formal )* )? ;
	[GrammarRule("formalList")]
	private MiniJavaParser.formalList_return formalList()
	{
		EnterRule_formalList();
		EnterRule("formalList", 11);
		TraceIn("formalList", 11);
		MiniJavaParser.formalList_return retval = new MiniJavaParser.formalList_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken COMMA29 = default(IToken);
		MiniJavaParser.formal_return formalDecl = default(MiniJavaParser.formal_return);

		CommonTree COMMA29_tree = default(CommonTree);


				retval.valueList = new List<BaseSymbol>();
			
		try { DebugEnterRule(GrammarFileName, "formalList");
		DebugLocation(263, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:268:2: ( (formalDecl= formal ( COMMA formalDecl= formal )* )? )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:269:3: (formalDecl= formal ( COMMA formalDecl= formal )* )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(269, 3);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:269:3: (formalDecl= formal ( COMMA formalDecl= formal )* )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_0 = input.LA(1);

			if ((LA7_0==BOOLEAN||LA7_0==DOUBLE||LA7_0==ID||LA7_0==INT))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:269:5: formalDecl= formal ( COMMA formalDecl= formal )*
				{
				DebugLocation(269, 16);
				PushFollow(Follow._formal_in_formalList710);
				formalDecl=formal();
				PopFollow();

				adaptor.AddChild(root_0, formalDecl.Tree);
				DebugLocation(270, 3);

							retval.valueList.Add(formalDecl.value);
						
				DebugLocation(273, 3);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:273:3: ( COMMA formalDecl= formal )*
				try { DebugEnterSubRule(6);
				while (true)
				{
					int alt6=2;
					try { DebugEnterDecision(6, false);
					int LA6_0 = input.LA(1);

					if ((LA6_0==COMMA))
					{
						alt6 = 1;
					}


					} finally { DebugExitDecision(6); }
					switch ( alt6 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:273:5: COMMA formalDecl= formal
						{
						DebugLocation(273, 10);
						COMMA29=(IToken)Match(input,COMMA,Follow._COMMA_in_formalList720); 
						DebugLocation(273, 23);
						PushFollow(Follow._formal_in_formalList727);
						formalDecl=formal();
						PopFollow();

						adaptor.AddChild(root_0, formalDecl.Tree);
						DebugLocation(274, 3);

									retval.valueList.Add(formalDecl.value);
								

						}
						break;

					default:
						goto loop6;
					}
				}

				loop6:
					;

				} finally { DebugExitSubRule(6); }


				}
				break;

			}
			} finally { DebugExitSubRule(7); }

			DebugLocation(278, 3);
			 
						// formallllll
						//#formalList = #(#[FORMALLIST], #formalList); 
					

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("formalList", 11);
			LeaveRule("formalList", 11);
			LeaveRule_formalList();
		}
		DebugLocation(282, 1);
		} finally { DebugExitRule(GrammarFileName, "formalList"); }
		return retval;

	}
	// $ANTLR end "formalList"

	private sealed partial class formal_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public NonTerm value;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public formal_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_formal();
	partial void LeaveRule_formal();

	// $ANTLR start "formal"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:284:1: formal returns [ NonTerm value ] : variable= varDecl ;
	[GrammarRule("formal")]
	private MiniJavaParser.formal_return formal()
	{
		EnterRule_formal();
		EnterRule("formal", 12);
		TraceIn("formal", 12);
		MiniJavaParser.formal_return retval = new MiniJavaParser.formal_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		MiniJavaParser.varDecl_return variable = default(MiniJavaParser.varDecl_return);


		try { DebugEnterRule(GrammarFileName, "formal");
		DebugLocation(284, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:285:2: (variable= varDecl )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:286:3: variable= varDecl
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(286, 12);
			PushFollow(Follow._varDecl_in_formal766);
			variable=varDecl();
			PopFollow();

			adaptor.AddChild(root_0, variable.Tree);
			DebugLocation(287, 3);

						retval.value = variable.value;
					

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("formal", 12);
			LeaveRule("formal", 12);
			LeaveRule_formal();
		}
		DebugLocation(290, 1);
		} finally { DebugExitRule(GrammarFileName, "formal"); }
		return retval;

	}
	// $ANTLR end "formal"

	private sealed partial class primitiveType_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public BaseSymbol value;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public primitiveType_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_primitiveType();
	partial void LeaveRule_primitiveType();

	// $ANTLR start "primitiveType"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:293:1: primitiveType returns [ BaseSymbol value ] : (token= ID | BOOLEAN | INT | DOUBLE );
	[GrammarRule("primitiveType")]
	private MiniJavaParser.primitiveType_return primitiveType()
	{
		EnterRule_primitiveType();
		EnterRule("primitiveType", 13);
		TraceIn("primitiveType", 13);
		MiniJavaParser.primitiveType_return retval = new MiniJavaParser.primitiveType_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken token = default(IToken);
		IToken BOOLEAN30 = default(IToken);
		IToken INT31 = default(IToken);
		IToken DOUBLE32 = default(IToken);

		CommonTree token_tree = default(CommonTree);
		CommonTree BOOLEAN30_tree = default(CommonTree);
		CommonTree INT31_tree = default(CommonTree);
		CommonTree DOUBLE32_tree = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "primitiveType");
		DebugLocation(293, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:294:2: (token= ID | BOOLEAN | INT | DOUBLE )
			int alt8=4;
			try { DebugEnterDecision(8, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt8 = 1;
				}
				break;
			case BOOLEAN:
				{
				alt8 = 2;
				}
				break;
			case INT:
				{
				alt8 = 3;
				}
				break;
			case DOUBLE:
				{
				alt8 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:295:3: token= ID
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(295, 9);
				token=(IToken)Match(input,ID,Follow._ID_in_primitiveType794); 
				token_tree = (CommonTree)adaptor.Create(token);
				adaptor.AddChild(root_0, token_tree);

				DebugLocation(296, 3);

							retval.value = new Token(TokenType.ID, token.Text, token);
						

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:300:3: BOOLEAN
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(300, 3);
				BOOLEAN30=(IToken)Match(input,BOOLEAN,Follow._BOOLEAN_in_primitiveType806); 
				BOOLEAN30_tree = (CommonTree)adaptor.Create(BOOLEAN30);
				adaptor.AddChild(root_0, BOOLEAN30_tree);

				DebugLocation(301, 3);

							retval.value = new Token(TokenType.BOOLEAN, token);
						

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:305:3: INT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(305, 3);
				INT31=(IToken)Match(input,INT,Follow._INT_in_primitiveType818); 
				INT31_tree = (CommonTree)adaptor.Create(INT31);
				adaptor.AddChild(root_0, INT31_tree);

				DebugLocation(306, 3);

							retval.value = new Token(TokenType.INT, token);
						

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:310:3: DOUBLE
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(310, 3);
				DOUBLE32=(IToken)Match(input,DOUBLE,Follow._DOUBLE_in_primitiveType829); 
				DOUBLE32_tree = (CommonTree)adaptor.Create(DOUBLE32);
				adaptor.AddChild(root_0, DOUBLE32_tree);

				DebugLocation(311, 3);

							retval.value = new Token(TokenType.FLOAT, token);
						

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primitiveType", 13);
			LeaveRule("primitiveType", 13);
			LeaveRule_primitiveType();
		}
		DebugLocation(314, 1);
		} finally { DebugExitRule(GrammarFileName, "primitiveType"); }
		return retval;

	}
	// $ANTLR end "primitiveType"

	private sealed partial class type_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public BaseSymbol value;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public type_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_type();
	partial void LeaveRule_type();

	// $ANTLR start "type"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:317:1: type returns [ BaseSymbol value ] : (typeDecl= primitiveType ( LBRACK RBRACK )* ) ;
	[GrammarRule("type")]
	private MiniJavaParser.type_return type()
	{
		EnterRule_type();
		EnterRule("type", 14);
		TraceIn("type", 14);
		MiniJavaParser.type_return retval = new MiniJavaParser.type_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LBRACK33 = default(IToken);
		IToken RBRACK34 = default(IToken);
		MiniJavaParser.primitiveType_return typeDecl = default(MiniJavaParser.primitiveType_return);

		CommonTree LBRACK33_tree = default(CommonTree);
		CommonTree RBRACK34_tree = default(CommonTree);


				//List<BaseSymbol> arrayList = new List<BaseSymbol>();
				int indexArrayBrackets = 0;
			
		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(317, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:323:2: ( (typeDecl= primitiveType ( LBRACK RBRACK )* ) )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:324:3: (typeDecl= primitiveType ( LBRACK RBRACK )* )
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(324, 3);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:324:3: (typeDecl= primitiveType ( LBRACK RBRACK )* )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:324:5: typeDecl= primitiveType ( LBRACK RBRACK )*
			{
			DebugLocation(324, 14);
			PushFollow(Follow._primitiveType_in_type867);
			typeDecl=primitiveType();
			PopFollow();

			adaptor.AddChild(root_0, typeDecl.Tree);
			DebugLocation(325, 3);

					
					
			DebugLocation(328, 3);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:328:3: ( LBRACK RBRACK )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if ((LA9_0==LBRACK))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:328:5: LBRACK RBRACK
					{
					DebugLocation(328, 5);
					LBRACK33=(IToken)Match(input,LBRACK,Follow._LBRACK_in_type877); 
					LBRACK33_tree = (CommonTree)adaptor.Create(LBRACK33);
					adaptor.AddChild(root_0, LBRACK33_tree);

					DebugLocation(328, 12);
					RBRACK34=(IToken)Match(input,RBRACK,Follow._RBRACK_in_type879); 
					RBRACK34_tree = (CommonTree)adaptor.Create(RBRACK34);
					adaptor.AddChild(root_0, RBRACK34_tree);

					DebugLocation(329, 3);

								indexArrayBrackets++;
							

					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }


			}

			DebugLocation(334, 3);

						if (indexArrayBrackets == 0)
						{
							retval.value = typeDecl.value;
						}
						else
						{
							retval.value = NonTermFactory.CreateArrayDecl(typeDecl.value, indexArrayBrackets);
						}
					

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type", 14);
			LeaveRule("type", 14);
			LeaveRule_type();
		}
		DebugLocation(344, 1);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return retval;

	}
	// $ANTLR end "type"

	private sealed partial class constant_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public BaseSymbol value;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public constant_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_constant();
	partial void LeaveRule_constant();

	// $ANTLR start "constant"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:349:1: constant returns [ BaseSymbol value ] : (constantDecl= FLOAT |constantDecl= INTEGER |constantDecl= NULL |constantDecl= TRUE |constantDecl= FALSE );
	[GrammarRule("constant")]
	private MiniJavaParser.constant_return constant()
	{
		EnterRule_constant();
		EnterRule("constant", 15);
		TraceIn("constant", 15);
		MiniJavaParser.constant_return retval = new MiniJavaParser.constant_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken constantDecl = default(IToken);

		CommonTree constantDecl_tree = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "constant");
		DebugLocation(349, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:350:2: (constantDecl= FLOAT |constantDecl= INTEGER |constantDecl= NULL |constantDecl= TRUE |constantDecl= FALSE )
			int alt10=5;
			try { DebugEnterDecision(10, false);
			switch (input.LA(1))
			{
			case FLOAT:
				{
				alt10 = 1;
				}
				break;
			case INTEGER:
				{
				alt10 = 2;
				}
				break;
			case NULL:
				{
				alt10 = 3;
				}
				break;
			case TRUE:
				{
				alt10 = 4;
				}
				break;
			case FALSE:
				{
				alt10 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:351:3: constantDecl= FLOAT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(351, 16);
				constantDecl=(IToken)Match(input,FLOAT,Follow._FLOAT_in_constant923); 
				constantDecl_tree = (CommonTree)adaptor.Create(constantDecl);
				adaptor.AddChild(root_0, constantDecl_tree);

				DebugLocation(352, 3);

							retval.value = new Token(TokenType.FLOAT, constantDecl.Text, constantDecl);
						

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:356:3: constantDecl= INTEGER
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(356, 16);
				constantDecl=(IToken)Match(input,INTEGER,Follow._INTEGER_in_constant938); 
				constantDecl_tree = (CommonTree)adaptor.Create(constantDecl);
				adaptor.AddChild(root_0, constantDecl_tree);

				DebugLocation(357, 3);

							retval.value = new Token(TokenType.INTEGER, constantDecl.Text, constantDecl);
						

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:361:3: constantDecl= NULL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(361, 16);
				constantDecl=(IToken)Match(input,NULL,Follow._NULL_in_constant953); 
				constantDecl_tree = (CommonTree)adaptor.Create(constantDecl);
				adaptor.AddChild(root_0, constantDecl_tree);

				DebugLocation(362, 3);

							retval.value = new Token(TokenType.NULL, constantDecl.Text, constantDecl);
						

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:366:3: constantDecl= TRUE
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(366, 16);
				constantDecl=(IToken)Match(input,TRUE,Follow._TRUE_in_constant969); 
				constantDecl_tree = (CommonTree)adaptor.Create(constantDecl);
				adaptor.AddChild(root_0, constantDecl_tree);

				DebugLocation(367, 3);

							retval.value = new Token(TokenType.BOOL, constantDecl.Text, constantDecl);
						

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:372:3: constantDecl= FALSE
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(372, 16);
				constantDecl=(IToken)Match(input,FALSE,Follow._FALSE_in_constant989); 
				constantDecl_tree = (CommonTree)adaptor.Create(constantDecl);
				adaptor.AddChild(root_0, constantDecl_tree);

				DebugLocation(373, 3);

							retval.value = new Token(TokenType.BOOL, constantDecl.Text, constantDecl);
						

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("constant", 15);
			LeaveRule("constant", 15);
			LeaveRule_constant();
		}
		DebugLocation(377, 1);
		} finally { DebugExitRule(GrammarFileName, "constant"); }
		return retval;

	}
	// $ANTLR end "constant"

	private sealed partial class argList_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public List<BaseSymbol> valueList;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public argList_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_argList();
	partial void LeaveRule_argList();

	// $ANTLR start "argList"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:381:1: argList returns [ List<BaseSymbol> valueList ] : (expressionListDecl= expressionList |) ;
	[GrammarRule("argList")]
	private MiniJavaParser.argList_return argList()
	{
		EnterRule_argList();
		EnterRule("argList", 16);
		TraceIn("argList", 16);
		MiniJavaParser.argList_return retval = new MiniJavaParser.argList_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		MiniJavaParser.expressionList_return expressionListDecl = default(MiniJavaParser.expressionList_return);


		try { DebugEnterRule(GrammarFileName, "argList");
		DebugLocation(381, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:382:2: ( (expressionListDecl= expressionList |) )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:383:3: (expressionListDecl= expressionList |)
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(383, 3);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:383:3: (expressionListDecl= expressionList |)
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_0 = input.LA(1);

			if (((LA11_0>=FALSE && LA11_0<=FLOAT)||LA11_0==ID||LA11_0==INTEGER||LA11_0==LNOT||LA11_0==LPAREN||LA11_0==MINUS||(LA11_0>=NEW && LA11_0<=NULL)||LA11_0==TRUE))
			{
				alt11 = 1;
			}
			else if ((LA11_0==RPAREN))
			{
				alt11 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:383:5: expressionListDecl= expressionList
				{
				DebugLocation(383, 24);
				PushFollow(Follow._expressionList_in_argList1022);
				expressionListDecl=expressionList();
				PopFollow();

				adaptor.AddChild(root_0, expressionListDecl.Tree);
				DebugLocation(384, 3);

							retval.valueList = expressionListDecl.valueList;
						

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:389:3: 
				{
				DebugLocation(389, 3);
				 
							//#argList = #[ELIST]; 
							retval.valueList = new List<BaseSymbol>();
						

				}
				break;

			}
			} finally { DebugExitSubRule(11); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("argList", 16);
			LeaveRule("argList", 16);
			LeaveRule_argList();
		}
		DebugLocation(394, 1);
		} finally { DebugExitRule(GrammarFileName, "argList"); }
		return retval;

	}
	// $ANTLR end "argList"

	private sealed partial class stmt_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public NonTerm value;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public stmt_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_stmt();
	partial void LeaveRule_stmt();

	// $ANTLR start "stmt"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:397:1: stmt returns [ NonTerm value ] : ( LCURLY statementList= stmtList RCURLY | IF LPAREN expression= expr RPAREN statementIf= stmt ( ELSE statementElse= stmt )? | WHILE LPAREN expression= expr RPAREN statement= stmt | ( PRINT | PRINT2 ) LPAREN expression= expr RPAREN SEMI | (variable= varDecl ) ( ASSIGN expression= expr )? SEMI | (id= ID ) ( LBRACK expressionBracket= expr RBRACK )* ( ASSIGN expression= expr )? SEMI );
	[GrammarRule("stmt")]
	private MiniJavaParser.stmt_return stmt()
	{
		EnterRule_stmt();
		EnterRule("stmt", 17);
		TraceIn("stmt", 17);
		MiniJavaParser.stmt_return retval = new MiniJavaParser.stmt_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken id = default(IToken);
		IToken LCURLY35 = default(IToken);
		IToken RCURLY36 = default(IToken);
		IToken IF37 = default(IToken);
		IToken LPAREN38 = default(IToken);
		IToken RPAREN39 = default(IToken);
		IToken ELSE40 = default(IToken);
		IToken WHILE41 = default(IToken);
		IToken LPAREN42 = default(IToken);
		IToken RPAREN43 = default(IToken);
		IToken PRINT44 = default(IToken);
		IToken PRINT245 = default(IToken);
		IToken LPAREN46 = default(IToken);
		IToken RPAREN47 = default(IToken);
		IToken SEMI48 = default(IToken);
		IToken ASSIGN49 = default(IToken);
		IToken SEMI50 = default(IToken);
		IToken LBRACK51 = default(IToken);
		IToken RBRACK52 = default(IToken);
		IToken ASSIGN53 = default(IToken);
		IToken SEMI54 = default(IToken);
		MiniJavaParser.stmtList_return statementList = default(MiniJavaParser.stmtList_return);
		MiniJavaParser.expr_return expression = default(MiniJavaParser.expr_return);
		MiniJavaParser.stmt_return statementIf = default(MiniJavaParser.stmt_return);
		MiniJavaParser.stmt_return statementElse = default(MiniJavaParser.stmt_return);
		MiniJavaParser.stmt_return statement = default(MiniJavaParser.stmt_return);
		MiniJavaParser.varDecl_return variable = default(MiniJavaParser.varDecl_return);
		MiniJavaParser.expr_return expressionBracket = default(MiniJavaParser.expr_return);

		CommonTree id_tree = default(CommonTree);
		CommonTree LCURLY35_tree = default(CommonTree);
		CommonTree RCURLY36_tree = default(CommonTree);
		CommonTree IF37_tree = default(CommonTree);
		CommonTree LPAREN38_tree = default(CommonTree);
		CommonTree RPAREN39_tree = default(CommonTree);
		CommonTree ELSE40_tree = default(CommonTree);
		CommonTree WHILE41_tree = default(CommonTree);
		CommonTree LPAREN42_tree = default(CommonTree);
		CommonTree RPAREN43_tree = default(CommonTree);
		CommonTree PRINT44_tree = default(CommonTree);
		CommonTree PRINT245_tree = default(CommonTree);
		CommonTree LPAREN46_tree = default(CommonTree);
		CommonTree RPAREN47_tree = default(CommonTree);
		CommonTree SEMI48_tree = default(CommonTree);
		CommonTree ASSIGN49_tree = default(CommonTree);
		CommonTree SEMI50_tree = default(CommonTree);
		CommonTree LBRACK51_tree = default(CommonTree);
		CommonTree RBRACK52_tree = default(CommonTree);
		CommonTree ASSIGN53_tree = default(CommonTree);
		CommonTree SEMI54_tree = default(CommonTree);


				List<BaseSymbol> bracketExpressionList = new List<BaseSymbol>();
			
		try { DebugEnterRule(GrammarFileName, "stmt");
		DebugLocation(397, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:402:2: ( LCURLY statementList= stmtList RCURLY | IF LPAREN expression= expr RPAREN statementIf= stmt ( ELSE statementElse= stmt )? | WHILE LPAREN expression= expr RPAREN statement= stmt | ( PRINT | PRINT2 ) LPAREN expression= expr RPAREN SEMI | (variable= varDecl ) ( ASSIGN expression= expr )? SEMI | (id= ID ) ( LBRACK expressionBracket= expr RBRACK )* ( ASSIGN expression= expr )? SEMI )
			int alt17=6;
			try { DebugEnterDecision(17, false);
			switch (input.LA(1))
			{
			case LCURLY:
				{
				alt17 = 1;
				}
				break;
			case IF:
				{
				alt17 = 2;
				}
				break;
			case WHILE:
				{
				alt17 = 3;
				}
				break;
			case PRINT:
			case PRINT2:
				{
				alt17 = 4;
				}
				break;
			case ID:
				{
				switch (input.LA(2))
				{
				case LBRACK:
					{
					int LA17_7 = input.LA(3);

					if ((LA17_7==RBRACK))
					{
						alt17 = 5;
					}
					else if (((LA17_7>=FALSE && LA17_7<=FLOAT)||LA17_7==ID||LA17_7==INTEGER||LA17_7==LNOT||LA17_7==LPAREN||LA17_7==MINUS||(LA17_7>=NEW && LA17_7<=NULL)||LA17_7==TRUE))
					{
						alt17 = 6;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 17, 7, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case ID:
					{
					alt17 = 5;
					}
					break;
				case ASSIGN:
				case SEMI:
					{
					alt17 = 6;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 17, 5, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			case BOOLEAN:
			case DOUBLE:
			case INT:
				{
				alt17 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 17, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:403:3: LCURLY statementList= stmtList RCURLY
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(403, 9);
				LCURLY35=(IToken)Match(input,LCURLY,Follow._LCURLY_in_stmt1070); 
				DebugLocation(403, 25);
				PushFollow(Follow._stmtList_in_stmt1077);
				statementList=stmtList();
				PopFollow();

				adaptor.AddChild(root_0, statementList.Tree);
				DebugLocation(403, 42);
				RCURLY36=(IToken)Match(input,RCURLY,Follow._RCURLY_in_stmt1079); 
				DebugLocation(404, 3);

							retval.value = NonTermFactory.CreateStatementList(statementList.valueList);
						

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:408:3: IF LPAREN expression= expr RPAREN statementIf= stmt ( ELSE statementElse= stmt )?
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(408, 5);
				IF37=(IToken)Match(input,IF,Follow._IF_in_stmt1092); 
				IF37_tree = (CommonTree)adaptor.Create(IF37);
				root_0 = (CommonTree)adaptor.BecomeRoot(IF37_tree, root_0);

				DebugLocation(408, 13);
				LPAREN38=(IToken)Match(input,LPAREN,Follow._LPAREN_in_stmt1095); 
				DebugLocation(408, 26);
				PushFollow(Follow._expr_in_stmt1102);
				expression=expr();
				PopFollow();

				adaptor.AddChild(root_0, expression.Tree);
				DebugLocation(408, 39);
				RPAREN39=(IToken)Match(input,RPAREN,Follow._RPAREN_in_stmt1104); 
				DebugLocation(408, 53);
				PushFollow(Follow._stmt_in_stmt1111);
				statementIf=stmt();
				PopFollow();

				adaptor.AddChild(root_0, statementIf.Tree);
				DebugLocation(408, 60);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:408:60: ( ELSE statementElse= stmt )?
				int alt12=2;
				try { DebugEnterSubRule(12);
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if ((LA12_0==ELSE))
				{
					alt12 = 1;
				}
				} finally { DebugExitDecision(12); }
				switch (alt12)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:408:61: ELSE statementElse= stmt
					{
					DebugLocation(408, 65);
					ELSE40=(IToken)Match(input,ELSE,Follow._ELSE_in_stmt1114); 
					ELSE40_tree = (CommonTree)adaptor.Create(ELSE40);
					root_0 = (CommonTree)adaptor.BecomeRoot(ELSE40_tree, root_0);

					DebugLocation(408, 81);
					PushFollow(Follow._stmt_in_stmt1121);
					statementElse=stmt();
					PopFollow();

					adaptor.AddChild(root_0, statementElse.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(12); }

				DebugLocation(409, 3);

							if (statementElse == null)
							{
								retval.value = NonTermFactory.CreateIfStatement(expression.value, statementIf.value);
							}
							else
							{
								retval.value = NonTermFactory.CreateIfElseStatement(expression.value, statementIf.value, statementElse.value);
							}
						

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:420:3: WHILE LPAREN expression= expr RPAREN statement= stmt
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(420, 8);
				WHILE41=(IToken)Match(input,WHILE,Follow._WHILE_in_stmt1135); 
				WHILE41_tree = (CommonTree)adaptor.Create(WHILE41);
				root_0 = (CommonTree)adaptor.BecomeRoot(WHILE41_tree, root_0);

				DebugLocation(420, 16);
				LPAREN42=(IToken)Match(input,LPAREN,Follow._LPAREN_in_stmt1138); 
				DebugLocation(420, 29);
				PushFollow(Follow._expr_in_stmt1145);
				expression=expr();
				PopFollow();

				adaptor.AddChild(root_0, expression.Tree);
				DebugLocation(420, 42);
				RPAREN43=(IToken)Match(input,RPAREN,Follow._RPAREN_in_stmt1147); 
				DebugLocation(420, 54);
				PushFollow(Follow._stmt_in_stmt1154);
				statement=stmt();
				PopFollow();

				adaptor.AddChild(root_0, statement.Tree);
				DebugLocation(421, 3);

							retval.value = NonTermFactory.CreateWhileStatement(expression.value, statement.value);
						

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:426:3: ( PRINT | PRINT2 ) LPAREN expression= expr RPAREN SEMI
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(426, 3);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:426:3: ( PRINT | PRINT2 )
				int alt13=2;
				try { DebugEnterSubRule(13);
				try { DebugEnterDecision(13, false);
				int LA13_0 = input.LA(1);

				if ((LA13_0==PRINT))
				{
					alt13 = 1;
				}
				else if ((LA13_0==PRINT2))
				{
					alt13 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(13); }
				switch (alt13)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:426:4: PRINT
					{
					DebugLocation(426, 9);
					PRINT44=(IToken)Match(input,PRINT,Follow._PRINT_in_stmt1168); 
					PRINT44_tree = (CommonTree)adaptor.Create(PRINT44);
					root_0 = (CommonTree)adaptor.BecomeRoot(PRINT44_tree, root_0);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:426:13: PRINT2
					{
					DebugLocation(426, 19);
					PRINT245=(IToken)Match(input,PRINT2,Follow._PRINT2_in_stmt1173); 
					PRINT245_tree = (CommonTree)adaptor.Create(PRINT245);
					root_0 = (CommonTree)adaptor.BecomeRoot(PRINT245_tree, root_0);


					}
					break;

				}
				} finally { DebugExitSubRule(13); }

				DebugLocation(426, 28);
				LPAREN46=(IToken)Match(input,LPAREN,Follow._LPAREN_in_stmt1177); 
				DebugLocation(426, 41);
				PushFollow(Follow._expr_in_stmt1184);
				expression=expr();
				PopFollow();

				adaptor.AddChild(root_0, expression.Tree);
				DebugLocation(426, 54);
				RPAREN47=(IToken)Match(input,RPAREN,Follow._RPAREN_in_stmt1186); 
				DebugLocation(426, 60);
				SEMI48=(IToken)Match(input,SEMI,Follow._SEMI_in_stmt1189); 
				DebugLocation(427, 3);

							retval.value = NonTermFactory.CreatePrintStatement(expression.value);
						

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:431:3: (variable= varDecl ) ( ASSIGN expression= expr )? SEMI
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(431, 3);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:431:3: (variable= varDecl )
				DebugEnterAlt(1);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:431:4: variable= varDecl
				{
				DebugLocation(431, 13);
				PushFollow(Follow._varDecl_in_stmt1207);
				variable=varDecl();
				PopFollow();

				adaptor.AddChild(root_0, variable.Tree);

				}

				DebugLocation(431, 24);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:431:24: ( ASSIGN expression= expr )?
				int alt14=2;
				try { DebugEnterSubRule(14);
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==ASSIGN))
				{
					alt14 = 1;
				}
				} finally { DebugExitDecision(14); }
				switch (alt14)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:431:25: ASSIGN expression= expr
					{
					DebugLocation(431, 31);
					ASSIGN49=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_stmt1211); 
					ASSIGN49_tree = (CommonTree)adaptor.Create(ASSIGN49);
					root_0 = (CommonTree)adaptor.BecomeRoot(ASSIGN49_tree, root_0);

					DebugLocation(431, 44);
					PushFollow(Follow._expr_in_stmt1218);
					expression=expr();
					PopFollow();

					adaptor.AddChild(root_0, expression.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(14); }

				DebugLocation(431, 57);
				SEMI50=(IToken)Match(input,SEMI,Follow._SEMI_in_stmt1222); 
				DebugLocation(432, 3);

							
							retval.value = NonTermFactory.CreateAssignVarStatementt(variable.value, expression != null ? expression.value : null);
						

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:437:3: (id= ID ) ( LBRACK expressionBracket= expr RBRACK )* ( ASSIGN expression= expr )? SEMI
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(437, 3);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:437:3: (id= ID )
				DebugEnterAlt(1);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:437:4: id= ID
				{
				DebugLocation(437, 7);
				id=(IToken)Match(input,ID,Follow._ID_in_stmt1240); 
				id_tree = (CommonTree)adaptor.Create(id);
				adaptor.AddChild(root_0, id_tree);


				}

				DebugLocation(438, 3);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:438:3: ( LBRACK expressionBracket= expr RBRACK )*
				try { DebugEnterSubRule(15);
				while (true)
				{
					int alt15=2;
					try { DebugEnterDecision(15, false);
					int LA15_0 = input.LA(1);

					if ((LA15_0==LBRACK))
					{
						alt15 = 1;
					}


					} finally { DebugExitDecision(15); }
					switch ( alt15 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:439:4: LBRACK expressionBracket= expr RBRACK
						{
						DebugLocation(439, 10);
						LBRACK51=(IToken)Match(input,LBRACK,Follow._LBRACK_in_stmt1251); 
						DebugLocation(439, 30);
						PushFollow(Follow._expr_in_stmt1258);
						expressionBracket=expr();
						PopFollow();

						adaptor.AddChild(root_0, expressionBracket.Tree);
						DebugLocation(439, 43);
						RBRACK52=(IToken)Match(input,RBRACK,Follow._RBRACK_in_stmt1260); 
						DebugLocation(440, 4);

										bracketExpressionList.Add(expressionBracket.value);
									

						}
						break;

					default:
						goto loop15;
					}
				}

				loop15:
					;

				} finally { DebugExitSubRule(15); }

				DebugLocation(443, 7);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:443:7: ( ASSIGN expression= expr )?
				int alt16=2;
				try { DebugEnterSubRule(16);
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if ((LA16_0==ASSIGN))
				{
					alt16 = 1;
				}
				} finally { DebugExitDecision(16); }
				switch (alt16)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:443:8: ASSIGN expression= expr
					{
					DebugLocation(443, 14);
					ASSIGN53=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_stmt1275); 
					ASSIGN53_tree = (CommonTree)adaptor.Create(ASSIGN53);
					root_0 = (CommonTree)adaptor.BecomeRoot(ASSIGN53_tree, root_0);

					DebugLocation(443, 27);
					PushFollow(Follow._expr_in_stmt1282);
					expression=expr();
					PopFollow();

					adaptor.AddChild(root_0, expression.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(16); }

				DebugLocation(443, 40);
				SEMI54=(IToken)Match(input,SEMI,Follow._SEMI_in_stmt1286); 
				DebugLocation(444, 3);

							if (bracketExpressionList.Count == 0)
							{
								retval.value = NonTermFactory.CreateAssignIdStatement(new Token(TokenType.ID, id.Text, id), expression != null ? expression.value : null);
							}
							else
							{
								retval.value = NonTermFactory.CreateArrayAssignIdStatement(new Token(TokenType.ID, id.Text, id), expression != null ? expression.value : null, bracketExpressionList);
							}
						

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stmt", 17);
			LeaveRule("stmt", 17);
			LeaveRule_stmt();
		}
		DebugLocation(454, 1);
		} finally { DebugExitRule(GrammarFileName, "stmt"); }
		return retval;

	}
	// $ANTLR end "stmt"

	private sealed partial class varDecl_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public NonTerm value;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public varDecl_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_varDecl();
	partial void LeaveRule_varDecl();

	// $ANTLR start "varDecl"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:456:1: varDecl returns [ NonTerm value ] : typeDecl= type id= ID ;
	[GrammarRule("varDecl")]
	private MiniJavaParser.varDecl_return varDecl()
	{
		EnterRule_varDecl();
		EnterRule("varDecl", 18);
		TraceIn("varDecl", 18);
		MiniJavaParser.varDecl_return retval = new MiniJavaParser.varDecl_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken id = default(IToken);
		MiniJavaParser.type_return typeDecl = default(MiniJavaParser.type_return);

		CommonTree id_tree = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "varDecl");
		DebugLocation(456, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:457:2: (typeDecl= type id= ID )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:458:3: typeDecl= type id= ID
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(458, 12);
			PushFollow(Follow._type_in_varDecl1312);
			typeDecl=type();
			PopFollow();

			adaptor.AddChild(root_0, typeDecl.Tree);
			DebugLocation(458, 23);
			id=(IToken)Match(input,ID,Follow._ID_in_varDecl1319); 
			id_tree = (CommonTree)adaptor.Create(id);
			adaptor.AddChild(root_0, id_tree);

			DebugLocation(459, 3);

						retval.value = NonTermFactory.CreateVarDecl(typeDecl.value, new Token(TokenType.ID, id.Text, id));
					

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("varDecl", 18);
			LeaveRule("varDecl", 18);
			LeaveRule_varDecl();
		}
		DebugLocation(463, 1);
		} finally { DebugExitRule(GrammarFileName, "varDecl"); }
		return retval;

	}
	// $ANTLR end "varDecl"

	private sealed partial class expr_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public BaseSymbol value;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public expr_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:477:1: expr returns [ BaseSymbol value ] : expression= logicalOrExpression ;
	[GrammarRule("expr")]
	private MiniJavaParser.expr_return expr()
	{
		EnterRule_expr();
		EnterRule("expr", 19);
		TraceIn("expr", 19);
		MiniJavaParser.expr_return retval = new MiniJavaParser.expr_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		MiniJavaParser.logicalOrExpression_return expression = default(MiniJavaParser.logicalOrExpression_return);


		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(477, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:478:2: (expression= logicalOrExpression )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:479:3: expression= logicalOrExpression
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(479, 15);
			PushFollow(Follow._logicalOrExpression_in_expr1360);
			expression=logicalOrExpression();
			PopFollow();

			adaptor.AddChild(root_0, expression.Tree);
			DebugLocation(480, 3);

						retval.value = expression.value;
					

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 19);
			LeaveRule("expr", 19);
			LeaveRule_expr();
		}
		DebugLocation(483, 1);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	private sealed partial class expressionList_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public List<BaseSymbol> valueList;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public expressionList_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_expressionList();
	partial void LeaveRule_expressionList();

	// $ANTLR start "expressionList"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:485:1: expressionList returns [ List<BaseSymbol> valueList ] : expression= expr ( COMMA expression= expr )* ;
	[GrammarRule("expressionList")]
	private MiniJavaParser.expressionList_return expressionList()
	{
		EnterRule_expressionList();
		EnterRule("expressionList", 20);
		TraceIn("expressionList", 20);
		MiniJavaParser.expressionList_return retval = new MiniJavaParser.expressionList_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken COMMA55 = default(IToken);
		MiniJavaParser.expr_return expression = default(MiniJavaParser.expr_return);

		CommonTree COMMA55_tree = default(CommonTree);


				retval.valueList = new List<BaseSymbol>();
			
		try { DebugEnterRule(GrammarFileName, "expressionList");
		DebugLocation(485, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:490:2: (expression= expr ( COMMA expression= expr )* )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:491:3: expression= expr ( COMMA expression= expr )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(491, 14);
			PushFollow(Follow._expr_in_expressionList1392);
			expression=expr();
			PopFollow();

			adaptor.AddChild(root_0, expression.Tree);
			DebugLocation(492, 3);

						retval.valueList.Add(expression.value);
					
			DebugLocation(495, 3);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:495:3: ( COMMA expression= expr )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_0 = input.LA(1);

				if ((LA18_0==COMMA))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:495:5: COMMA expression= expr
					{
					DebugLocation(495, 10);
					COMMA55=(IToken)Match(input,COMMA,Follow._COMMA_in_expressionList1403); 
					DebugLocation(495, 24);
					PushFollow(Follow._expr_in_expressionList1411);
					expression=expr();
					PopFollow();

					adaptor.AddChild(root_0, expression.Tree);
					DebugLocation(496, 3);
					 
								//#expressionList = #(#[ELIST], expressionList); 
								retval.valueList.Add(expression.value);
							

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expressionList", 20);
			LeaveRule("expressionList", 20);
			LeaveRule_expressionList();
		}
		DebugLocation(502, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionList"); }
		return retval;

	}
	// $ANTLR end "expressionList"

	private sealed partial class logicalOrExpression_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public BaseSymbol value;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public logicalOrExpression_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_logicalOrExpression();
	partial void LeaveRule_logicalOrExpression();

	// $ANTLR start "logicalOrExpression"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:505:1: logicalOrExpression returns [ BaseSymbol value ] : expression= logicalAndExpression ( LOR expression= logicalAndExpression )* ;
	[GrammarRule("logicalOrExpression")]
	private MiniJavaParser.logicalOrExpression_return logicalOrExpression()
	{
		EnterRule_logicalOrExpression();
		EnterRule("logicalOrExpression", 21);
		TraceIn("logicalOrExpression", 21);
		MiniJavaParser.logicalOrExpression_return retval = new MiniJavaParser.logicalOrExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LOR56 = default(IToken);
		MiniJavaParser.logicalAndExpression_return expression = default(MiniJavaParser.logicalAndExpression_return);

		CommonTree LOR56_tree = default(CommonTree);


				List<BaseSymbol> valueList = new List<BaseSymbol>();
			
		try { DebugEnterRule(GrammarFileName, "logicalOrExpression");
		DebugLocation(505, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:510:2: (expression= logicalAndExpression ( LOR expression= logicalAndExpression )* )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:511:3: expression= logicalAndExpression ( LOR expression= logicalAndExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(511, 14);
			PushFollow(Follow._logicalAndExpression_in_logicalOrExpression1453);
			expression=logicalAndExpression();
			PopFollow();

			adaptor.AddChild(root_0, expression.Tree);
			DebugLocation(512, 3);

						valueList.Add(expression.value);
					
			DebugLocation(515, 3);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:515:3: ( LOR expression= logicalAndExpression )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_0 = input.LA(1);

				if ((LA19_0==LOR))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:515:5: LOR expression= logicalAndExpression
					{
					DebugLocation(515, 8);
					LOR56=(IToken)Match(input,LOR,Follow._LOR_in_logicalOrExpression1463); 
					LOR56_tree = (CommonTree)adaptor.Create(LOR56);
					root_0 = (CommonTree)adaptor.BecomeRoot(LOR56_tree, root_0);

					DebugLocation(515, 21);
					PushFollow(Follow._logicalAndExpression_in_logicalOrExpression1470);
					expression=logicalAndExpression();
					PopFollow();

					adaptor.AddChild(root_0, expression.Tree);
					DebugLocation(516, 3);

								valueList.Add(expression.value);
							

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }

			DebugLocation(520, 3);

						/*if (valueList.Count == 1)
						{
							retval.value = valueList.First();
						}
						else
						{
							retval.value = NonTerm.CreateLogicalOrExpression(valueList);
						}*/
						retval.value = NonTermFactory.CreateLogicalOrExpression(valueList);
					

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalOrExpression", 21);
			LeaveRule("logicalOrExpression", 21);
			LeaveRule_logicalOrExpression();
		}
		DebugLocation(531, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalOrExpression"); }
		return retval;

	}
	// $ANTLR end "logicalOrExpression"

	private sealed partial class logicalAndExpression_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public BaseSymbol value;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public logicalAndExpression_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_logicalAndExpression();
	partial void LeaveRule_logicalAndExpression();

	// $ANTLR start "logicalAndExpression"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:534:1: logicalAndExpression returns [ BaseSymbol value ] : expression= equalityExpression ( LAND expression= equalityExpression )* ;
	[GrammarRule("logicalAndExpression")]
	private MiniJavaParser.logicalAndExpression_return logicalAndExpression()
	{
		EnterRule_logicalAndExpression();
		EnterRule("logicalAndExpression", 22);
		TraceIn("logicalAndExpression", 22);
		MiniJavaParser.logicalAndExpression_return retval = new MiniJavaParser.logicalAndExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LAND57 = default(IToken);
		MiniJavaParser.equalityExpression_return expression = default(MiniJavaParser.equalityExpression_return);

		CommonTree LAND57_tree = default(CommonTree);


				List<BaseSymbol> valueList = new List<BaseSymbol>();
			
		try { DebugEnterRule(GrammarFileName, "logicalAndExpression");
		DebugLocation(534, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:539:2: (expression= equalityExpression ( LAND expression= equalityExpression )* )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:540:3: expression= equalityExpression ( LAND expression= equalityExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(540, 14);
			PushFollow(Follow._equalityExpression_in_logicalAndExpression1513);
			expression=equalityExpression();
			PopFollow();

			adaptor.AddChild(root_0, expression.Tree);
			DebugLocation(541, 3);

						valueList.Add(expression.value);
					
			DebugLocation(544, 3);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:544:3: ( LAND expression= equalityExpression )*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_0 = input.LA(1);

				if ((LA20_0==LAND))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:544:5: LAND expression= equalityExpression
					{
					DebugLocation(544, 9);
					LAND57=(IToken)Match(input,LAND,Follow._LAND_in_logicalAndExpression1524); 
					LAND57_tree = (CommonTree)adaptor.Create(LAND57);
					root_0 = (CommonTree)adaptor.BecomeRoot(LAND57_tree, root_0);

					DebugLocation(544, 22);
					PushFollow(Follow._equalityExpression_in_logicalAndExpression1531);
					expression=equalityExpression();
					PopFollow();

					adaptor.AddChild(root_0, expression.Tree);
					DebugLocation(545, 3);

								valueList.Add(expression.value);
							

					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }

			DebugLocation(549, 3);

						//retval.value = expression.value;
						retval.value = NonTermFactory.CreateLogicalAndExpression(valueList);
					

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalAndExpression", 22);
			LeaveRule("logicalAndExpression", 22);
			LeaveRule_logicalAndExpression();
		}
		DebugLocation(553, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalAndExpression"); }
		return retval;

	}
	// $ANTLR end "logicalAndExpression"

	private sealed partial class equalityExpression_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public BaseSymbol value;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public equalityExpression_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_equalityExpression();
	partial void LeaveRule_equalityExpression();

	// $ANTLR start "equalityExpression"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:557:1: equalityExpression returns [ BaseSymbol value ] : expression= relationalExpression ( (token= EQUAL |token= NEQUAL ) expression= relationalExpression )? ;
	[GrammarRule("equalityExpression")]
	private MiniJavaParser.equalityExpression_return equalityExpression()
	{
		EnterRule_equalityExpression();
		EnterRule("equalityExpression", 23);
		TraceIn("equalityExpression", 23);
		MiniJavaParser.equalityExpression_return retval = new MiniJavaParser.equalityExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken token = default(IToken);
		MiniJavaParser.relationalExpression_return expression = default(MiniJavaParser.relationalExpression_return);

		CommonTree token_tree = default(CommonTree);


				List<BaseSymbol> valueList = new List<BaseSymbol>();
				//IToken token = null;
			
		try { DebugEnterRule(GrammarFileName, "equalityExpression");
		DebugLocation(557, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:563:2: (expression= relationalExpression ( (token= EQUAL |token= NEQUAL ) expression= relationalExpression )? )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:564:3: expression= relationalExpression ( (token= EQUAL |token= NEQUAL ) expression= relationalExpression )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(564, 14);
			PushFollow(Follow._relationalExpression_in_equalityExpression1575);
			expression=relationalExpression();
			PopFollow();

			adaptor.AddChild(root_0, expression.Tree);
			DebugLocation(565, 3);

						valueList.Add(expression.value);
					
			DebugLocation(568, 3);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:568:3: ( (token= EQUAL |token= NEQUAL ) expression= relationalExpression )?
			int alt22=2;
			try { DebugEnterSubRule(22);
			try { DebugEnterDecision(22, false);
			int LA22_0 = input.LA(1);

			if ((LA22_0==EQUAL||LA22_0==NEQUAL))
			{
				alt22 = 1;
			}
			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:568:5: (token= EQUAL |token= NEQUAL ) expression= relationalExpression
				{
				DebugLocation(568, 5);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:568:5: (token= EQUAL |token= NEQUAL )
				int alt21=2;
				try { DebugEnterSubRule(21);
				try { DebugEnterDecision(21, false);
				int LA21_0 = input.LA(1);

				if ((LA21_0==EQUAL))
				{
					alt21 = 1;
				}
				else if ((LA21_0==NEQUAL))
				{
					alt21 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 21, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(21); }
				switch (alt21)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:568:6: token= EQUAL
					{
					DebugLocation(568, 12);
					token=(IToken)Match(input,EQUAL,Follow._EQUAL_in_equalityExpression1591); 
					token_tree = (CommonTree)adaptor.Create(token);
					root_0 = (CommonTree)adaptor.BecomeRoot(token_tree, root_0);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:568:23: token= NEQUAL
					{
					DebugLocation(568, 29);
					token=(IToken)Match(input,NEQUAL,Follow._NEQUAL_in_equalityExpression1600); 
					token_tree = (CommonTree)adaptor.Create(token);
					root_0 = (CommonTree)adaptor.BecomeRoot(token_tree, root_0);


					}
					break;

				}
				} finally { DebugExitSubRule(21); }

				DebugLocation(568, 51);
				PushFollow(Follow._relationalExpression_in_equalityExpression1608);
				expression=relationalExpression();
				PopFollow();

				adaptor.AddChild(root_0, expression.Tree);
				DebugLocation(569, 3);

							valueList.Add(expression.value);
						

				}
				break;

			}
			} finally { DebugExitSubRule(22); }

			DebugLocation(573, 3);

						//retval.value = expression.value;
						retval.value = NonTermFactory.CreateEqualityExpression(token == null ? NONE : token.Type, valueList);
					

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equalityExpression", 23);
			LeaveRule("equalityExpression", 23);
			LeaveRule_equalityExpression();
		}
		DebugLocation(577, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityExpression"); }
		return retval;

	}
	// $ANTLR end "equalityExpression"

	private sealed partial class relationalExpression_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public BaseSymbol value;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public relationalExpression_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_relationalExpression();
	partial void LeaveRule_relationalExpression();

	// $ANTLR start "relationalExpression"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:580:1: relationalExpression returns [ BaseSymbol value ] : expression= additiveExpression ( (token= LESS |token= LESSEQ |token= MOREEQ |token= MORE ) expression= additiveExpression )* ;
	[GrammarRule("relationalExpression")]
	private MiniJavaParser.relationalExpression_return relationalExpression()
	{
		EnterRule_relationalExpression();
		EnterRule("relationalExpression", 24);
		TraceIn("relationalExpression", 24);
		MiniJavaParser.relationalExpression_return retval = new MiniJavaParser.relationalExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken token = default(IToken);
		MiniJavaParser.additiveExpression_return expression = default(MiniJavaParser.additiveExpression_return);

		CommonTree token_tree = default(CommonTree);


				List<BaseSymbol> valueList = new List<BaseSymbol>();
			
		try { DebugEnterRule(GrammarFileName, "relationalExpression");
		DebugLocation(580, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:585:2: (expression= additiveExpression ( (token= LESS |token= LESSEQ |token= MOREEQ |token= MORE ) expression= additiveExpression )* )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:586:3: expression= additiveExpression ( (token= LESS |token= LESSEQ |token= MOREEQ |token= MORE ) expression= additiveExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(586, 14);
			PushFollow(Follow._additiveExpression_in_relationalExpression1651);
			expression=additiveExpression();
			PopFollow();

			adaptor.AddChild(root_0, expression.Tree);
			DebugLocation(587, 3);

						//valueList.Add(expression.value);
						retval.value = expression.value;
					
			DebugLocation(591, 3);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:591:3: ( (token= LESS |token= LESSEQ |token= MOREEQ |token= MORE ) expression= additiveExpression )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, false);
				int LA24_0 = input.LA(1);

				if (((LA24_0>=LESS && LA24_0<=LESSEQ)||(LA24_0>=MORE && LA24_0<=MOREEQ)))
				{
					alt24 = 1;
				}


				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:591:4: (token= LESS |token= LESSEQ |token= MOREEQ |token= MORE ) expression= additiveExpression
					{
					DebugLocation(591, 4);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:591:4: (token= LESS |token= LESSEQ |token= MOREEQ |token= MORE )
					int alt23=4;
					try { DebugEnterSubRule(23);
					try { DebugEnterDecision(23, false);
					switch (input.LA(1))
					{
					case LESS:
						{
						alt23 = 1;
						}
						break;
					case LESSEQ:
						{
						alt23 = 2;
						}
						break;
					case MOREEQ:
						{
						alt23 = 3;
						}
						break;
					case MORE:
						{
						alt23 = 4;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 23, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(23); }
					switch (alt23)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:591:5: token= LESS
						{
						DebugLocation(591, 11);
						token=(IToken)Match(input,LESS,Follow._LESS_in_relationalExpression1666); 
						token_tree = (CommonTree)adaptor.Create(token);
						root_0 = (CommonTree)adaptor.BecomeRoot(token_tree, root_0);


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:591:21: token= LESSEQ
						{
						DebugLocation(591, 27);
						token=(IToken)Match(input,LESSEQ,Follow._LESSEQ_in_relationalExpression1675); 
						token_tree = (CommonTree)adaptor.Create(token);
						root_0 = (CommonTree)adaptor.BecomeRoot(token_tree, root_0);


						}
						break;
					case 3:
						DebugEnterAlt(3);
						// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:591:39: token= MOREEQ
						{
						DebugLocation(591, 45);
						token=(IToken)Match(input,MOREEQ,Follow._MOREEQ_in_relationalExpression1684); 
						token_tree = (CommonTree)adaptor.Create(token);
						root_0 = (CommonTree)adaptor.BecomeRoot(token_tree, root_0);


						}
						break;
					case 4:
						DebugEnterAlt(4);
						// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:591:57: token= MORE
						{
						DebugLocation(591, 63);
						token=(IToken)Match(input,MORE,Follow._MORE_in_relationalExpression1693); 
						token_tree = (CommonTree)adaptor.Create(token);
						root_0 = (CommonTree)adaptor.BecomeRoot(token_tree, root_0);


						}
						break;

					}
					} finally { DebugExitSubRule(23); }

					DebugLocation(591, 83);
					PushFollow(Follow._additiveExpression_in_relationalExpression1701);
					expression=additiveExpression();
					PopFollow();

					adaptor.AddChild(root_0, expression.Tree);
					DebugLocation(592, 3);

								retval.value = NonTermFactory.CreateExpression(token == null ? NONE : token.Type, retval.value, expression.value);
							

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }

			DebugLocation(596, 3);

						//retval.value = expression.value;
					

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalExpression", 24);
			LeaveRule("relationalExpression", 24);
			LeaveRule_relationalExpression();
		}
		DebugLocation(599, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpression"); }
		return retval;

	}
	// $ANTLR end "relationalExpression"

	private sealed partial class additiveExpression_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public BaseSymbol value;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public additiveExpression_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_additiveExpression();
	partial void LeaveRule_additiveExpression();

	// $ANTLR start "additiveExpression"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:602:1: additiveExpression returns [ BaseSymbol value ] : expression= multiplicativeExpression ( (token= PLUS |token= MINUS ) expression= multiplicativeExpression )* ;
	[GrammarRule("additiveExpression")]
	private MiniJavaParser.additiveExpression_return additiveExpression()
	{
		EnterRule_additiveExpression();
		EnterRule("additiveExpression", 25);
		TraceIn("additiveExpression", 25);
		MiniJavaParser.additiveExpression_return retval = new MiniJavaParser.additiveExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken token = default(IToken);
		MiniJavaParser.multiplicativeExpression_return expression = default(MiniJavaParser.multiplicativeExpression_return);

		CommonTree token_tree = default(CommonTree);


				List<BaseSymbol> valueList = new List<BaseSymbol>();
			
		try { DebugEnterRule(GrammarFileName, "additiveExpression");
		DebugLocation(602, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:607:2: (expression= multiplicativeExpression ( (token= PLUS |token= MINUS ) expression= multiplicativeExpression )* )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:608:3: expression= multiplicativeExpression ( (token= PLUS |token= MINUS ) expression= multiplicativeExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(608, 14);
			PushFollow(Follow._multiplicativeExpression_in_additiveExpression1744);
			expression=multiplicativeExpression();
			PopFollow();

			adaptor.AddChild(root_0, expression.Tree);
			DebugLocation(609, 3);

						retval.value = expression.value;
					
			DebugLocation(612, 3);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:612:3: ( (token= PLUS |token= MINUS ) expression= multiplicativeExpression )*
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=2;
				try { DebugEnterDecision(26, false);
				int LA26_0 = input.LA(1);

				if ((LA26_0==MINUS||LA26_0==PLUS))
				{
					alt26 = 1;
				}


				} finally { DebugExitDecision(26); }
				switch ( alt26 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:612:4: (token= PLUS |token= MINUS ) expression= multiplicativeExpression
					{
					DebugLocation(612, 4);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:612:4: (token= PLUS |token= MINUS )
					int alt25=2;
					try { DebugEnterSubRule(25);
					try { DebugEnterDecision(25, false);
					int LA25_0 = input.LA(1);

					if ((LA25_0==PLUS))
					{
						alt25 = 1;
					}
					else if ((LA25_0==MINUS))
					{
						alt25 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 25, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(25); }
					switch (alt25)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:612:5: token= PLUS
						{
						DebugLocation(612, 11);
						token=(IToken)Match(input,PLUS,Follow._PLUS_in_additiveExpression1759); 
						token_tree = (CommonTree)adaptor.Create(token);
						root_0 = (CommonTree)adaptor.BecomeRoot(token_tree, root_0);


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:612:21: token= MINUS
						{
						DebugLocation(612, 27);
						token=(IToken)Match(input,MINUS,Follow._MINUS_in_additiveExpression1768); 
						token_tree = (CommonTree)adaptor.Create(token);
						root_0 = (CommonTree)adaptor.BecomeRoot(token_tree, root_0);


						}
						break;

					}
					} finally { DebugExitSubRule(25); }

					DebugLocation(612, 48);
					PushFollow(Follow._multiplicativeExpression_in_additiveExpression1776);
					expression=multiplicativeExpression();
					PopFollow();

					adaptor.AddChild(root_0, expression.Tree);
					DebugLocation(613, 3);

								retval.value = NonTermFactory.CreateExpression(token == null ? NONE : token.Type, retval.value, expression.value);
							

					}
					break;

				default:
					goto loop26;
				}
			}

			loop26:
				;

			} finally { DebugExitSubRule(26); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("additiveExpression", 25);
			LeaveRule("additiveExpression", 25);
			LeaveRule_additiveExpression();
		}
		DebugLocation(618, 1);
		} finally { DebugExitRule(GrammarFileName, "additiveExpression"); }
		return retval;

	}
	// $ANTLR end "additiveExpression"

	private sealed partial class multiplicativeExpression_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public BaseSymbol value;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public multiplicativeExpression_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_multiplicativeExpression();
	partial void LeaveRule_multiplicativeExpression();

	// $ANTLR start "multiplicativeExpression"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:621:1: multiplicativeExpression returns [ BaseSymbol value ] : expression= decoratedExpression ( (token= STAR |token= DIV ) expression= decoratedExpression )* ;
	[GrammarRule("multiplicativeExpression")]
	private MiniJavaParser.multiplicativeExpression_return multiplicativeExpression()
	{
		EnterRule_multiplicativeExpression();
		EnterRule("multiplicativeExpression", 26);
		TraceIn("multiplicativeExpression", 26);
		MiniJavaParser.multiplicativeExpression_return retval = new MiniJavaParser.multiplicativeExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken token = default(IToken);
		MiniJavaParser.decoratedExpression_return expression = default(MiniJavaParser.decoratedExpression_return);

		CommonTree token_tree = default(CommonTree);


				List<BaseSymbol> valueList = new List<BaseSymbol>();
			
		try { DebugEnterRule(GrammarFileName, "multiplicativeExpression");
		DebugLocation(621, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:626:2: (expression= decoratedExpression ( (token= STAR |token= DIV ) expression= decoratedExpression )* )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:627:3: expression= decoratedExpression ( (token= STAR |token= DIV ) expression= decoratedExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(627, 14);
			PushFollow(Follow._decoratedExpression_in_multiplicativeExpression1818);
			expression=decoratedExpression();
			PopFollow();

			adaptor.AddChild(root_0, expression.Tree);
			DebugLocation(628, 3);

						retval.value = expression.value;
					
			DebugLocation(631, 3);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:631:3: ( (token= STAR |token= DIV ) expression= decoratedExpression )*
			try { DebugEnterSubRule(28);
			while (true)
			{
				int alt28=2;
				try { DebugEnterDecision(28, false);
				int LA28_0 = input.LA(1);

				if ((LA28_0==DIV||LA28_0==STAR))
				{
					alt28 = 1;
				}


				} finally { DebugExitDecision(28); }
				switch ( alt28 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:631:4: (token= STAR |token= DIV ) expression= decoratedExpression
					{
					DebugLocation(631, 4);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:631:4: (token= STAR |token= DIV )
					int alt27=2;
					try { DebugEnterSubRule(27);
					try { DebugEnterDecision(27, false);
					int LA27_0 = input.LA(1);

					if ((LA27_0==STAR))
					{
						alt27 = 1;
					}
					else if ((LA27_0==DIV))
					{
						alt27 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 27, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(27); }
					switch (alt27)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:631:5: token= STAR
						{
						DebugLocation(631, 11);
						token=(IToken)Match(input,STAR,Follow._STAR_in_multiplicativeExpression1833); 
						token_tree = (CommonTree)adaptor.Create(token);
						root_0 = (CommonTree)adaptor.BecomeRoot(token_tree, root_0);


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:631:21: token= DIV
						{
						DebugLocation(631, 27);
						token=(IToken)Match(input,DIV,Follow._DIV_in_multiplicativeExpression1842); 
						token_tree = (CommonTree)adaptor.Create(token);
						root_0 = (CommonTree)adaptor.BecomeRoot(token_tree, root_0);


						}
						break;

					}
					} finally { DebugExitSubRule(27); }

					DebugLocation(631, 46);
					PushFollow(Follow._decoratedExpression_in_multiplicativeExpression1850);
					expression=decoratedExpression();
					PopFollow();

					adaptor.AddChild(root_0, expression.Tree);
					DebugLocation(632, 3);

								retval.value = NonTermFactory.CreateExpression(token == null ? NONE : token.Type, retval.value, expression.value);
							

					}
					break;

				default:
					goto loop28;
				}
			}

			loop28:
				;

			} finally { DebugExitSubRule(28); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multiplicativeExpression", 26);
			LeaveRule("multiplicativeExpression", 26);
			LeaveRule_multiplicativeExpression();
		}
		DebugLocation(637, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplicativeExpression"); }
		return retval;

	}
	// $ANTLR end "multiplicativeExpression"

	private sealed partial class decoratedExpression_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public BaseSymbol value;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public decoratedExpression_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_decoratedExpression();
	partial void LeaveRule_decoratedExpression();

	// $ANTLR start "decoratedExpression"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:639:1: decoratedExpression returns [ BaseSymbol value ] : ( MINUS decoratedExpressionDecl= decoratedExpression | LNOT decoratedExpressionDecl= decoratedExpression |expression= primaryExpression ( ( DOT id= ID ( LPAREN argListDecl= argList RPAREN )? )? | ( LPAREN methodArgListDecl= argList RPAREN ) ) );
	[GrammarRule("decoratedExpression")]
	private MiniJavaParser.decoratedExpression_return decoratedExpression()
	{
		EnterRule_decoratedExpression();
		EnterRule("decoratedExpression", 27);
		TraceIn("decoratedExpression", 27);
		MiniJavaParser.decoratedExpression_return retval = new MiniJavaParser.decoratedExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken id = default(IToken);
		IToken MINUS58 = default(IToken);
		IToken LNOT59 = default(IToken);
		IToken DOT60 = default(IToken);
		IToken LPAREN61 = default(IToken);
		IToken RPAREN62 = default(IToken);
		IToken LPAREN63 = default(IToken);
		IToken RPAREN64 = default(IToken);
		MiniJavaParser.decoratedExpression_return decoratedExpressionDecl = default(MiniJavaParser.decoratedExpression_return);
		MiniJavaParser.primaryExpression_return expression = default(MiniJavaParser.primaryExpression_return);
		MiniJavaParser.argList_return argListDecl = default(MiniJavaParser.argList_return);
		MiniJavaParser.argList_return methodArgListDecl = default(MiniJavaParser.argList_return);

		CommonTree id_tree = default(CommonTree);
		CommonTree MINUS58_tree = default(CommonTree);
		CommonTree LNOT59_tree = default(CommonTree);
		CommonTree DOT60_tree = default(CommonTree);
		CommonTree LPAREN61_tree = default(CommonTree);
		CommonTree RPAREN62_tree = default(CommonTree);
		CommonTree LPAREN63_tree = default(CommonTree);
		CommonTree RPAREN64_tree = default(CommonTree);


				//List<BaseSymbol> argumentList = new List<BaseSymbol>();
				BaseSymbol methodArguments = null;
			
		try { DebugEnterRule(GrammarFileName, "decoratedExpression");
		DebugLocation(639, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:645:2: ( MINUS decoratedExpressionDecl= decoratedExpression | LNOT decoratedExpressionDecl= decoratedExpression |expression= primaryExpression ( ( DOT id= ID ( LPAREN argListDecl= argList RPAREN )? )? | ( LPAREN methodArgListDecl= argList RPAREN ) ) )
			int alt32=3;
			try { DebugEnterDecision(32, false);
			switch (input.LA(1))
			{
			case MINUS:
				{
				alt32 = 1;
				}
				break;
			case LNOT:
				{
				alt32 = 2;
				}
				break;
			case FALSE:
			case FLOAT:
			case ID:
			case INTEGER:
			case LPAREN:
			case NEW:
			case NULL:
			case TRUE:
				{
				alt32 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(32); }
			switch (alt32)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:650:3: MINUS decoratedExpressionDecl= decoratedExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(650, 8);
				MINUS58=(IToken)Match(input,MINUS,Follow._MINUS_in_decoratedExpression1900); 
				MINUS58_tree = (CommonTree)adaptor.Create(MINUS58);
				root_0 = (CommonTree)adaptor.BecomeRoot(MINUS58_tree, root_0);

				DebugLocation(650, 34);
				PushFollow(Follow._decoratedExpression_in_decoratedExpression1907);
				decoratedExpressionDecl=decoratedExpression();
				PopFollow();

				adaptor.AddChild(root_0, decoratedExpressionDecl.Tree);
				DebugLocation(651, 3);

							retval.value = NonTermFactory.CreateUnaryMinusExpression(decoratedExpressionDecl.value);
						

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:655:3: LNOT decoratedExpressionDecl= decoratedExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(655, 7);
				LNOT59=(IToken)Match(input,LNOT,Follow._LNOT_in_decoratedExpression1919); 
				LNOT59_tree = (CommonTree)adaptor.Create(LNOT59);
				root_0 = (CommonTree)adaptor.BecomeRoot(LNOT59_tree, root_0);

				DebugLocation(655, 33);
				PushFollow(Follow._decoratedExpression_in_decoratedExpression1926);
				decoratedExpressionDecl=decoratedExpression();
				PopFollow();

				adaptor.AddChild(root_0, decoratedExpressionDecl.Tree);
				DebugLocation(656, 3);

							retval.value = NonTermFactory.CreateUnaryNotExpression(decoratedExpressionDecl.value);
						

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:660:3: expression= primaryExpression ( ( DOT id= ID ( LPAREN argListDecl= argList RPAREN )? )? | ( LPAREN methodArgListDecl= argList RPAREN ) )
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(660, 14);
				PushFollow(Follow._primaryExpression_in_decoratedExpression1942);
				expression=primaryExpression();
				PopFollow();

				adaptor.AddChild(root_0, expression.Tree);
				DebugLocation(662, 4);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:662:4: ( ( DOT id= ID ( LPAREN argListDecl= argList RPAREN )? )? | ( LPAREN methodArgListDecl= argList RPAREN ) )
				int alt31=2;
				try { DebugEnterSubRule(31);
				try { DebugEnterDecision(31, false);
				int LA31_0 = input.LA(1);

				if ((LA31_0==COMMA||(LA31_0>=DIV && LA31_0<=DOT)||LA31_0==EQUAL||LA31_0==LAND||(LA31_0>=LESS && LA31_0<=LESSEQ)||LA31_0==LOR||(LA31_0>=MINUS && LA31_0<=NEQUAL)||LA31_0==PLUS||LA31_0==RBRACK||(LA31_0>=RPAREN && LA31_0<=SEMI)||LA31_0==STAR))
				{
					alt31 = 1;
				}
				else if ((LA31_0==LPAREN))
				{
					alt31 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 31, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(31); }
				switch (alt31)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:662:5: ( DOT id= ID ( LPAREN argListDecl= argList RPAREN )? )?
					{
					DebugLocation(662, 5);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:662:5: ( DOT id= ID ( LPAREN argListDecl= argList RPAREN )? )?
					int alt30=2;
					try { DebugEnterSubRule(30);
					try { DebugEnterDecision(30, false);
					int LA30_0 = input.LA(1);

					if ((LA30_0==DOT))
					{
						alt30 = 1;
					}
					} finally { DebugExitDecision(30); }
					switch (alt30)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:662:7: DOT id= ID ( LPAREN argListDecl= argList RPAREN )?
						{
						DebugLocation(662, 10);
						DOT60=(IToken)Match(input,DOT,Follow._DOT_in_decoratedExpression1955); 
						DOT60_tree = (CommonTree)adaptor.Create(DOT60);
						root_0 = (CommonTree)adaptor.BecomeRoot(DOT60_tree, root_0);

						DebugLocation(662, 16);
						id=(IToken)Match(input,ID,Follow._ID_in_decoratedExpression1963); 
						id_tree = (CommonTree)adaptor.Create(id);
						adaptor.AddChild(root_0, id_tree);

						DebugLocation(663, 5);
						// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:663:5: ( LPAREN argListDecl= argList RPAREN )?
						int alt29=2;
						try { DebugEnterSubRule(29);
						try { DebugEnterDecision(29, false);
						int LA29_0 = input.LA(1);

						if ((LA29_0==LPAREN))
						{
							alt29 = 1;
						}
						} finally { DebugExitDecision(29); }
						switch (alt29)
						{
						case 1:
							DebugEnterAlt(1);
							// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:663:7: LPAREN argListDecl= argList RPAREN
							{
							DebugLocation(663, 13);
							LPAREN61=(IToken)Match(input,LPAREN,Follow._LPAREN_in_decoratedExpression1972); 
							LPAREN61_tree = (CommonTree)adaptor.Create(LPAREN61);
							root_0 = (CommonTree)adaptor.BecomeRoot(LPAREN61_tree, root_0);

							DebugLocation(663, 27);
							PushFollow(Follow._argList_in_decoratedExpression1979);
							argListDecl=argList();
							PopFollow();

							adaptor.AddChild(root_0, argListDecl.Tree);
							DebugLocation(663, 43);
							RPAREN62=(IToken)Match(input,RPAREN,Follow._RPAREN_in_decoratedExpression1981); 
							DebugLocation(664, 5);

												methodArguments = NonTermFactory.CreateArgumentListExpression(argListDecl.valueList);
												//argumentList.Add(symbol);
												//argumentList = argListDecl.valueList;
											

							}
							break;

						}
						} finally { DebugExitSubRule(29); }

						DebugLocation(671, 4);

										
									

						}
						break;

					}
					} finally { DebugExitSubRule(30); }

					DebugLocation(676, 3);

								if (argListDecl == null)
								{
									/*if (id == null || !id.Text.Equals(TokenNames[LENGTH].ToLower()))
									{
										retval.value = expression.value;
									}
									else
									{
										retval.value = NonTerm.CreateLengthFunctionExpression(expression.value);
									}*/
									if (id == null)
									{
										retval.value = expression.value;
									}
									else if (!id.Text.Equals(TokenNames[LENGTH].ToLower()))
									{
										retval.value = NonTermFactory.CreateFieldExpression(expression.value, new Token(TokenType.ID, id.Text, id));
									}
									else
									{
										retval.value = NonTermFactory.CreateLengthFunctionExpression(expression.value);
									}
								}
								else
								{
									retval.value = NonTermFactory.CreateMethodCallListExpression(expression.value, new Token(TokenType.ID, id.Text, id), methodArguments);
								}
							

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:707:4: ( LPAREN methodArgListDecl= argList RPAREN )
					{
					DebugLocation(707, 4);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:707:4: ( LPAREN methodArgListDecl= argList RPAREN )
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:707:6: LPAREN methodArgListDecl= argList RPAREN
					{
					DebugLocation(707, 12);
					LPAREN63=(IToken)Match(input,LPAREN,Follow._LPAREN_in_decoratedExpression2032); 
					LPAREN63_tree = (CommonTree)adaptor.Create(LPAREN63);
					root_0 = (CommonTree)adaptor.BecomeRoot(LPAREN63_tree, root_0);

					DebugLocation(707, 32);
					PushFollow(Follow._argList_in_decoratedExpression2039);
					methodArgListDecl=argList();
					PopFollow();

					adaptor.AddChild(root_0, methodArgListDecl.Tree);
					DebugLocation(707, 48);
					RPAREN64=(IToken)Match(input,RPAREN,Follow._RPAREN_in_decoratedExpression2041); 

					}

					DebugLocation(708, 4);

									/*if (methodArgListDecl == null)
									{
										retval.value = expression.value;
									}
									else*/
									{
										retval.value = NonTermFactory.CreateMethodCallListExpression(expression.value, 
											NonTermFactory.CreateArgumentListExpression(methodArgListDecl.valueList));
									}
									
								

					}
					break;

				}
				} finally { DebugExitSubRule(31); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("decoratedExpression", 27);
			LeaveRule("decoratedExpression", 27);
			LeaveRule_decoratedExpression();
		}
		DebugLocation(726, 1);
		} finally { DebugExitRule(GrammarFileName, "decoratedExpression"); }
		return retval;

	}
	// $ANTLR end "decoratedExpression"

	private sealed partial class primaryExpression_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<CommonTree>, IAstRuleReturnScope
	{
		public BaseSymbol value;
		private CommonTree _tree;
		public CommonTree Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public primaryExpression_return(MiniJavaParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MiniJavaParser grammar);
	}

	partial void EnterRule_primaryExpression();
	partial void LeaveRule_primaryExpression();

	// $ANTLR start "primaryExpression"
	// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:728:1: primaryExpression returns [ BaseSymbol value ] : (token= ID ( LBRACK bracketExpression= logicalOrExpression RBRACK )* |constantDecl= constant | NEW typeDecl= primitiveType LPAREN RPAREN | NEW typeDecl= primitiveType ( LBRACK expressionDecl= expr RBRACK )+ | LPAREN expression= logicalOrExpression RPAREN );
	[GrammarRule("primaryExpression")]
	private MiniJavaParser.primaryExpression_return primaryExpression()
	{
		EnterRule_primaryExpression();
		EnterRule("primaryExpression", 28);
		TraceIn("primaryExpression", 28);
		MiniJavaParser.primaryExpression_return retval = new MiniJavaParser.primaryExpression_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken token = default(IToken);
		IToken LBRACK65 = default(IToken);
		IToken RBRACK66 = default(IToken);
		IToken NEW67 = default(IToken);
		IToken LPAREN68 = default(IToken);
		IToken RPAREN69 = default(IToken);
		IToken NEW70 = default(IToken);
		IToken LBRACK71 = default(IToken);
		IToken RBRACK72 = default(IToken);
		IToken LPAREN73 = default(IToken);
		IToken RPAREN74 = default(IToken);
		MiniJavaParser.logicalOrExpression_return bracketExpression = default(MiniJavaParser.logicalOrExpression_return);
		MiniJavaParser.constant_return constantDecl = default(MiniJavaParser.constant_return);
		MiniJavaParser.primitiveType_return typeDecl = default(MiniJavaParser.primitiveType_return);
		MiniJavaParser.expr_return expressionDecl = default(MiniJavaParser.expr_return);
		MiniJavaParser.logicalOrExpression_return expression = default(MiniJavaParser.logicalOrExpression_return);

		CommonTree token_tree = default(CommonTree);
		CommonTree LBRACK65_tree = default(CommonTree);
		CommonTree RBRACK66_tree = default(CommonTree);
		CommonTree NEW67_tree = default(CommonTree);
		CommonTree LPAREN68_tree = default(CommonTree);
		CommonTree RPAREN69_tree = default(CommonTree);
		CommonTree NEW70_tree = default(CommonTree);
		CommonTree LBRACK71_tree = default(CommonTree);
		CommonTree RBRACK72_tree = default(CommonTree);
		CommonTree LPAREN73_tree = default(CommonTree);
		CommonTree RPAREN74_tree = default(CommonTree);


				List<BaseSymbol> bracketExpressionList = new List<BaseSymbol>();
				List<BaseSymbol> bracketAssignmentExpressionList = new List<BaseSymbol>();
			
		try { DebugEnterRule(GrammarFileName, "primaryExpression");
		DebugLocation(728, 1);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:734:2: (token= ID ( LBRACK bracketExpression= logicalOrExpression RBRACK )* |constantDecl= constant | NEW typeDecl= primitiveType LPAREN RPAREN | NEW typeDecl= primitiveType ( LBRACK expressionDecl= expr RBRACK )+ | LPAREN expression= logicalOrExpression RPAREN )
			int alt35=5;
			try { DebugEnterDecision(35, false);
			try
			{
				alt35 = dfa35.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(35); }
			switch (alt35)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:735:3: token= ID ( LBRACK bracketExpression= logicalOrExpression RBRACK )*
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(735, 9);
				token=(IToken)Match(input,ID,Follow._ID_in_primaryExpression2084); 
				token_tree = (CommonTree)adaptor.Create(token);
				adaptor.AddChild(root_0, token_tree);

				DebugLocation(736, 3);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:736:3: ( LBRACK bracketExpression= logicalOrExpression RBRACK )*
				try { DebugEnterSubRule(33);
				while (true)
				{
					int alt33=2;
					try { DebugEnterDecision(33, false);
					int LA33_0 = input.LA(1);

					if ((LA33_0==LBRACK))
					{
						alt33 = 1;
					}


					} finally { DebugExitDecision(33); }
					switch ( alt33 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:736:5: LBRACK bracketExpression= logicalOrExpression RBRACK
						{
						DebugLocation(736, 11);
						LBRACK65=(IToken)Match(input,LBRACK,Follow._LBRACK_in_primaryExpression2091); 
						DebugLocation(736, 31);
						PushFollow(Follow._logicalOrExpression_in_primaryExpression2098);
						bracketExpression=logicalOrExpression();
						PopFollow();

						adaptor.AddChild(root_0, bracketExpression.Tree);
						DebugLocation(736, 59);
						RBRACK66=(IToken)Match(input,RBRACK,Follow._RBRACK_in_primaryExpression2100); 
						DebugLocation(737, 3);

									bracketAssignmentExpressionList.Add(bracketExpression.value);
								

						}
						break;

					default:
						goto loop33;
					}
				}

				loop33:
					;

				} finally { DebugExitSubRule(33); }

				DebugLocation(741, 3);
					
							if (bracketAssignmentExpressionList.Count == 0)
							{
								retval.value = new Token(TokenType.ID, token.Text, token);
							}
							else
							{
								retval.value = NonTermFactory.CreateArrayIndiciesStatement(new Token(TokenType.ID, token.Text, token), bracketAssignmentExpressionList);
							}
							
						

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:758:3: constantDecl= constant
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(758, 16);
				PushFollow(Follow._constant_in_primaryExpression2131);
				constantDecl=constant();
				PopFollow();

				adaptor.AddChild(root_0, constantDecl.Tree);
				DebugLocation(759, 3);

							retval.value = constantDecl.value;
						

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:763:3: NEW typeDecl= primitiveType LPAREN RPAREN
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(763, 6);
				NEW67=(IToken)Match(input,NEW,Follow._NEW_in_primaryExpression2143); 
				NEW67_tree = (CommonTree)adaptor.Create(NEW67);
				root_0 = (CommonTree)adaptor.BecomeRoot(NEW67_tree, root_0);

				DebugLocation(763, 17);
				PushFollow(Follow._primitiveType_in_primaryExpression2150);
				typeDecl=primitiveType();
				PopFollow();

				adaptor.AddChild(root_0, typeDecl.Tree);
				DebugLocation(763, 39);
				LPAREN68=(IToken)Match(input,LPAREN,Follow._LPAREN_in_primaryExpression2152); 
				DebugLocation(763, 47);
				RPAREN69=(IToken)Match(input,RPAREN,Follow._RPAREN_in_primaryExpression2155); 
				DebugLocation(764, 3);

							//retval.value = typeDecl.value;
							retval.value = NonTermFactory.CreateNewStatement(typeDecl.value);
						

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:769:3: NEW typeDecl= primitiveType ( LBRACK expressionDecl= expr RBRACK )+
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(769, 6);
				NEW70=(IToken)Match(input,NEW,Follow._NEW_in_primaryExpression2168); 
				NEW70_tree = (CommonTree)adaptor.Create(NEW70);
				root_0 = (CommonTree)adaptor.BecomeRoot(NEW70_tree, root_0);

				DebugLocation(769, 17);
				PushFollow(Follow._primitiveType_in_primaryExpression2175);
				typeDecl=primitiveType();
				PopFollow();

				adaptor.AddChild(root_0, typeDecl.Tree);
				DebugLocation(770, 3);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:770:3: ( LBRACK expressionDecl= expr RBRACK )+
				int cnt34=0;
				try { DebugEnterSubRule(34);
				while (true)
				{
					int alt34=2;
					try { DebugEnterDecision(34, false);
					int LA34_0 = input.LA(1);

					if ((LA34_0==LBRACK))
					{
						alt34 = 1;
					}


					} finally { DebugExitDecision(34); }
					switch (alt34)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:770:5: LBRACK expressionDecl= expr RBRACK
						{
						DebugLocation(770, 11);
						LBRACK71=(IToken)Match(input,LBRACK,Follow._LBRACK_in_primaryExpression2182); 
						DebugLocation(770, 28);
						PushFollow(Follow._expr_in_primaryExpression2189);
						expressionDecl=expr();
						PopFollow();

						adaptor.AddChild(root_0, expressionDecl.Tree);
						DebugLocation(770, 41);
						RBRACK72=(IToken)Match(input,RBRACK,Follow._RBRACK_in_primaryExpression2191); 
						DebugLocation(771, 4);

										bracketExpressionList.Add(expressionDecl.value);
									

						}
						break;

					default:
						if (cnt34 >= 1)
							goto loop34;

						EarlyExitException eee34 = new EarlyExitException( 34, input );
						DebugRecognitionException(eee34);
						throw eee34;
					}
					cnt34++;
				}
				loop34:
					;

				} finally { DebugExitSubRule(34); }

				DebugLocation(775, 3);

							//retval.value = typeDecl.value;
							retval.value = NonTermFactory.CreateNewArrayStatement(typeDecl.value, bracketExpressionList);
						

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:780:3: LPAREN expression= logicalOrExpression RPAREN
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(780, 9);
				LPAREN73=(IToken)Match(input,LPAREN,Follow._LPAREN_in_primaryExpression2215); 
				DebugLocation(780, 22);
				PushFollow(Follow._logicalOrExpression_in_primaryExpression2222);
				expression=logicalOrExpression();
				PopFollow();

				adaptor.AddChild(root_0, expression.Tree);
				DebugLocation(780, 50);
				RPAREN74=(IToken)Match(input,RPAREN,Follow._RPAREN_in_primaryExpression2224); 
				DebugLocation(781, 3);

							retval.value = expression.value;
						

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primaryExpression", 28);
			LeaveRule("primaryExpression", 28);
			LeaveRule_primaryExpression();
		}
		DebugLocation(790, 1);
		} finally { DebugExitRule(GrammarFileName, "primaryExpression"); }
		return retval;

	}
	// $ANTLR end "primaryExpression"
	#endregion Rules


	#region DFA
	private DFA35 dfa35;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa35 = new DFA35( this );
	}

	private class DFA35 : DFA
	{
		private const string DFA35_eotS =
			"\xB\xFFFF";
		private const string DFA35_eofS =
			"\xB\xFFFF";
		private const string DFA35_minS =
			"\x1\x16\x2\xFFFF\x1\x7\x1\xFFFF\x4\x1F\x2\xFFFF";
		private const string DFA35_maxS =
			"\x1\x44\x2\xFFFF\x1\x1C\x1\xFFFF\x4\x28\x2\xFFFF";
		private const string DFA35_acceptS =
			"\x1\xFFFF\x1\x1\x1\x2\x1\xFFFF\x1\x5\x4\xFFFF\x1\x3\x1\x4";
		private const string DFA35_specialS =
			"\xB\xFFFF}>";
		private static readonly string[] DFA35_transitionS =
			{
				"\x2\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\xA\xFFFF\x1\x4\x9\xFFFF\x1\x3\x1"+
				"\x2\x10\xFFFF\x1\x2",
				"",
				"",
				"\x1\x6\x8\xFFFF\x1\x8\x9\xFFFF\x1\x5\x1\xFFFF\x1\x7",
				"",
				"\x1\xA\x8\xFFFF\x1\x9",
				"\x1\xA\x8\xFFFF\x1\x9",
				"\x1\xA\x8\xFFFF\x1\x9",
				"\x1\xA\x8\xFFFF\x1\x9",
				"",
				""
			};

		private static readonly short[] DFA35_eot = DFA.UnpackEncodedString(DFA35_eotS);
		private static readonly short[] DFA35_eof = DFA.UnpackEncodedString(DFA35_eofS);
		private static readonly char[] DFA35_min = DFA.UnpackEncodedStringToUnsignedChars(DFA35_minS);
		private static readonly char[] DFA35_max = DFA.UnpackEncodedStringToUnsignedChars(DFA35_maxS);
		private static readonly short[] DFA35_accept = DFA.UnpackEncodedString(DFA35_acceptS);
		private static readonly short[] DFA35_special = DFA.UnpackEncodedString(DFA35_specialS);
		private static readonly short[][] DFA35_transition;

		static DFA35()
		{
			int numStates = DFA35_transitionS.Length;
			DFA35_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA35_transition[i] = DFA.UnpackEncodedString(DFA35_transitionS[i]);
			}
		}

		public DFA35( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 35;
			this.eot = DFA35_eot;
			this.eof = DFA35_eof;
			this.min = DFA35_min;
			this.max = DFA35_max;
			this.accept = DFA35_accept;
			this.special = DFA35_special;
			this.transition = DFA35_transition;
		}

		public override string Description { get { return "728:1: primaryExpression returns [ BaseSymbol value ] : (token= ID ( LBRACK bracketExpression= logicalOrExpression RBRACK )* |constantDecl= constant | NEW typeDecl= primitiveType LPAREN RPAREN | NEW typeDecl= primitiveType ( LBRACK expressionDecl= expr RBRACK )+ | LPAREN expression= logicalOrExpression RPAREN );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _mainClassDecl_in_program163 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _classDeclList_in_program167 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_program169 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _classDecl_in_classDeclList204 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _CLASS_in_mainClassDecl240 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _ID_in_mainClassDecl245 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _LCURLY_in_mainClassDecl247 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _PUBLIC_in_mainClassDecl253 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _STATIC_in_mainClassDecl256 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _VOID_in_mainClassDecl259 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _MAIN_in_mainClassDecl262 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _LPAREN_in_mainClassDecl265 = new BitSet(new ulong[]{0x0UL,0x4UL});
		public static readonly BitSet _STRING_in_mainClassDecl272 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _LBRACK_in_mainClassDecl275 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _RBRACK_in_mainClassDecl278 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _ID_in_mainClassDecl281 = new BitSet(new ulong[]{0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_mainClassDecl286 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _LCURLY_in_mainClassDecl292 = new BitSet(new ulong[]{0x46000011C010080UL,0x200UL});
		public static readonly BitSet _stmtList_in_mainClassDecl297 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _RCURLY_in_mainClassDecl299 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _RCURLY_in_mainClassDecl304 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _stmt_in_stmtList339 = new BitSet(new ulong[]{0x6000011C010082UL,0x200UL});
		public static readonly BitSet _classVarDecl_in_classVarDeclList384 = new BitSet(new ulong[]{0x14010082UL});
		public static readonly BitSet _type_in_classVarDecl420 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _ID_in_classVarDecl427 = new BitSet(new ulong[]{0x2000000000000000UL});
		public static readonly BitSet _SEMI_in_classVarDecl430 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EXTENDS_in_extendsClause454 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _ID_in_extendsClause461 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CLASS_in_classDecl508 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _ID_in_classDecl516 = new BitSet(new ulong[]{0x100200000UL});
		public static readonly BitSet _extendsClause_in_classDecl523 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _LCURLY_in_classDecl525 = new BitSet(new ulong[]{0x14010080UL});
		public static readonly BitSet _classVarDeclList_in_classDecl535 = new BitSet(new ulong[]{0x500000000000000UL});
		public static readonly BitSet _methodDeclList_in_classDecl544 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _RCURLY_in_classDecl548 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PUBLIC_in_methodDecl574 = new BitSet(new ulong[]{0x14010080UL});
		public static readonly BitSet _type_in_methodDecl581 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _ID_in_methodDecl587 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _LPAREN_in_methodDecl589 = new BitSet(new ulong[]{0x1000000014010080UL});
		public static readonly BitSet _formalList_in_methodDecl596 = new BitSet(new ulong[]{0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_methodDecl598 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _LCURLY_in_methodDecl601 = new BitSet(new ulong[]{0x86000011C010080UL,0x200UL});
		public static readonly BitSet _stmtList_in_methodDecl611 = new BitSet(new ulong[]{0x800000000000000UL});
		public static readonly BitSet _RETURN_in_methodDecl616 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _expr_in_methodDecl623 = new BitSet(new ulong[]{0x2000000000000000UL});
		public static readonly BitSet _SEMI_in_methodDecl625 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _RCURLY_in_methodDecl630 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _methodDecl_in_methodDeclList664 = new BitSet(new ulong[]{0x100000000000002UL});
		public static readonly BitSet _formal_in_formalList710 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _COMMA_in_formalList720 = new BitSet(new ulong[]{0x14010080UL});
		public static readonly BitSet _formal_in_formalList727 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _varDecl_in_formal766 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_primitiveType794 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BOOLEAN_in_primitiveType806 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_primitiveType818 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOUBLE_in_primitiveType829 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primitiveType_in_type867 = new BitSet(new ulong[]{0x80000002UL});
		public static readonly BitSet _LBRACK_in_type877 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _RBRACK_in_type879 = new BitSet(new ulong[]{0x80000002UL});
		public static readonly BitSet _FLOAT_in_constant923 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INTEGER_in_constant938 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NULL_in_constant953 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRUE_in_constant969 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FALSE_in_constant989 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionList_in_argList1022 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LCURLY_in_stmt1070 = new BitSet(new ulong[]{0x46000011C010080UL,0x200UL});
		public static readonly BitSet _stmtList_in_stmt1077 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _RCURLY_in_stmt1079 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_stmt1092 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _LPAREN_in_stmt1095 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _expr_in_stmt1102 = new BitSet(new ulong[]{0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_stmt1104 = new BitSet(new ulong[]{0x6000011C010080UL,0x200UL});
		public static readonly BitSet _stmt_in_stmt1111 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _ELSE_in_stmt1114 = new BitSet(new ulong[]{0x6000011C010080UL,0x200UL});
		public static readonly BitSet _stmt_in_stmt1121 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_stmt1135 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _LPAREN_in_stmt1138 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _expr_in_stmt1145 = new BitSet(new ulong[]{0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_stmt1147 = new BitSet(new ulong[]{0x6000011C010080UL,0x200UL});
		public static readonly BitSet _stmt_in_stmt1154 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PRINT_in_stmt1168 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _PRINT2_in_stmt1173 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _LPAREN_in_stmt1177 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _expr_in_stmt1184 = new BitSet(new ulong[]{0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_stmt1186 = new BitSet(new ulong[]{0x2000000000000000UL});
		public static readonly BitSet _SEMI_in_stmt1189 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _varDecl_in_stmt1207 = new BitSet(new ulong[]{0x2000000000000010UL});
		public static readonly BitSet _ASSIGN_in_stmt1211 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _expr_in_stmt1218 = new BitSet(new ulong[]{0x2000000000000000UL});
		public static readonly BitSet _SEMI_in_stmt1222 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_stmt1240 = new BitSet(new ulong[]{0x2000000080000010UL});
		public static readonly BitSet _LBRACK_in_stmt1251 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _expr_in_stmt1258 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _RBRACK_in_stmt1260 = new BitSet(new ulong[]{0x2000000080000010UL});
		public static readonly BitSet _ASSIGN_in_stmt1275 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _expr_in_stmt1282 = new BitSet(new ulong[]{0x2000000000000000UL});
		public static readonly BitSet _SEMI_in_stmt1286 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_in_varDecl1312 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _ID_in_varDecl1319 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalOrExpression_in_expr1360 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_expressionList1392 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _COMMA_in_expressionList1403 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _expr_in_expressionList1411 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _logicalAndExpression_in_logicalOrExpression1453 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _LOR_in_logicalOrExpression1463 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _logicalAndExpression_in_logicalOrExpression1470 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _equalityExpression_in_logicalAndExpression1513 = new BitSet(new ulong[]{0x40000002UL});
		public static readonly BitSet _LAND_in_logicalAndExpression1524 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _equalityExpression_in_logicalAndExpression1531 = new BitSet(new ulong[]{0x40000002UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression1575 = new BitSet(new ulong[]{0x2000000080002UL});
		public static readonly BitSet _EQUAL_in_equalityExpression1591 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _NEQUAL_in_equalityExpression1600 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression1608 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _additiveExpression_in_relationalExpression1651 = new BitSet(new ulong[]{0x1800C00000002UL});
		public static readonly BitSet _LESS_in_relationalExpression1666 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _LESSEQ_in_relationalExpression1675 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _MOREEQ_in_relationalExpression1684 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _MORE_in_relationalExpression1693 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _additiveExpression_in_relationalExpression1701 = new BitSet(new ulong[]{0x1800C00000002UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression1744 = new BitSet(new ulong[]{0x10400000000002UL});
		public static readonly BitSet _PLUS_in_additiveExpression1759 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _MINUS_in_additiveExpression1768 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression1776 = new BitSet(new ulong[]{0x10400000000002UL});
		public static readonly BitSet _decoratedExpression_in_multiplicativeExpression1818 = new BitSet(new ulong[]{0x8000000000004002UL});
		public static readonly BitSet _STAR_in_multiplicativeExpression1833 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _DIV_in_multiplicativeExpression1842 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _decoratedExpression_in_multiplicativeExpression1850 = new BitSet(new ulong[]{0x8000000000004002UL});
		public static readonly BitSet _MINUS_in_decoratedExpression1900 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _decoratedExpression_in_decoratedExpression1907 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LNOT_in_decoratedExpression1919 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _decoratedExpression_in_decoratedExpression1926 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryExpression_in_decoratedExpression1942 = new BitSet(new ulong[]{0x10000008002UL});
		public static readonly BitSet _DOT_in_decoratedExpression1955 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _ID_in_decoratedExpression1963 = new BitSet(new ulong[]{0x10000000002UL});
		public static readonly BitSet _LPAREN_in_decoratedExpression1972 = new BitSet(new ulong[]{0x100C414024C00000UL,0x10UL});
		public static readonly BitSet _argList_in_decoratedExpression1979 = new BitSet(new ulong[]{0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_decoratedExpression1981 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_decoratedExpression2032 = new BitSet(new ulong[]{0x100C414024C00000UL,0x10UL});
		public static readonly BitSet _argList_in_decoratedExpression2039 = new BitSet(new ulong[]{0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_decoratedExpression2041 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_primaryExpression2084 = new BitSet(new ulong[]{0x80000002UL});
		public static readonly BitSet _LBRACK_in_primaryExpression2091 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _logicalOrExpression_in_primaryExpression2098 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _RBRACK_in_primaryExpression2100 = new BitSet(new ulong[]{0x80000002UL});
		public static readonly BitSet _constant_in_primaryExpression2131 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEW_in_primaryExpression2143 = new BitSet(new ulong[]{0x14010080UL});
		public static readonly BitSet _primitiveType_in_primaryExpression2150 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _LPAREN_in_primaryExpression2152 = new BitSet(new ulong[]{0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_primaryExpression2155 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEW_in_primaryExpression2168 = new BitSet(new ulong[]{0x14010080UL});
		public static readonly BitSet _primitiveType_in_primaryExpression2175 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _LBRACK_in_primaryExpression2182 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _expr_in_primaryExpression2189 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _RBRACK_in_primaryExpression2191 = new BitSet(new ulong[]{0x80000002UL});
		public static readonly BitSet _LPAREN_in_primaryExpression2215 = new BitSet(new ulong[]{0xC414024C00000UL,0x10UL});
		public static readonly BitSet _logicalOrExpression_in_primaryExpression2222 = new BitSet(new ulong[]{0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_primaryExpression2224 = new BitSet(new ulong[]{0x2UL});

	}
	#endregion Follow sets
}

} // namespace  MiniJavaSyntax 
