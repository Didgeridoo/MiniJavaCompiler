//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.3.1.7705
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162


using System.Collections.Generic;
using Antlr.Runtime;

namespace  MiniJavaSyntax 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.3.1.7705")]
[System.CLSCompliant(false)]
public partial class MiniJavaLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int ASSIGN=4;
	public const int BLOCK_COMMENT=5;
	public const int BOOL=6;
	public const int BOOLEAN=7;
	public const int CLASS=8;
	public const int CLASSDECL=9;
	public const int CLASSVARDECL=10;
	public const int CLASSVARDECLLIST=11;
	public const int COMMA=12;
	public const int DIGIT=13;
	public const int DIV=14;
	public const int DOT=15;
	public const int DOUBLE=16;
	public const int ELIST=17;
	public const int ELSE=18;
	public const int EQUAL=19;
	public const int EXPONENT=20;
	public const int EXTENDS=21;
	public const int FALSE=22;
	public const int FLOAT=23;
	public const int FORMALLIST=24;
	public const int HIDDEN=25;
	public const int ID=26;
	public const int IF=27;
	public const int INT=28;
	public const int INTEGER=29;
	public const int LAND=30;
	public const int LBRACK=31;
	public const int LCURLY=32;
	public const int LENGTH=33;
	public const int LESS=34;
	public const int LESSEQ=35;
	public const int LETTER=36;
	public const int LINE_COMMENT=37;
	public const int LNOT=38;
	public const int LOR=39;
	public const int LPAREN=40;
	public const int MAIN=41;
	public const int MAINCLASSDECL=42;
	public const int METHODDECL=43;
	public const int METHODDECLLIST=44;
	public const int METHOD_CALL=45;
	public const int MINUS=46;
	public const int MORE=47;
	public const int MOREEQ=48;
	public const int NEQUAL=49;
	public const int NEW=50;
	public const int NULL=51;
	public const int PLUS=52;
	public const int PRINT=53;
	public const int PRINT2=54;
	public const int PROGRAM=55;
	public const int PUBLIC=56;
	public const int RBRACK=57;
	public const int RCURLY=58;
	public const int RETURN=59;
	public const int RPAREN=60;
	public const int SEMI=61;
	public const int SLIST=62;
	public const int STAR=63;
	public const int STATIC=64;
	public const int STMT=65;
	public const int STRING=66;
	public const int THIS=67;
	public const int TRUE=68;
	public const int TYPE=69;
	public const int UNARY_MINUS=70;
	public const int VARDECL=71;
	public const int VOID=72;
	public const int WHILE=73;
	public const int WHITESPACE=74;

    // delegates
    // delegators

	public MiniJavaLexer()
	{
		OnCreated();
	}

	public MiniJavaLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public MiniJavaLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{


		OnCreated();
	}
	public override string GrammarFileName { get { return "D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_CLASS();
	partial void LeaveRule_CLASS();

	// $ANTLR start "CLASS"
	[GrammarRule("CLASS")]
	private void mCLASS()
	{
		EnterRule_CLASS();
		EnterRule("CLASS", 1);
		TraceIn("CLASS", 1);
		try
		{
			int _type = CLASS;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:809:7: ( 'class' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:809:9: 'class'
			{
			DebugLocation(809, 9);
			Match("class"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CLASS", 1);
			LeaveRule("CLASS", 1);
			LeaveRule_CLASS();
		}
	}
	// $ANTLR end "CLASS"

	partial void EnterRule_PUBLIC();
	partial void LeaveRule_PUBLIC();

	// $ANTLR start "PUBLIC"
	[GrammarRule("PUBLIC")]
	private void mPUBLIC()
	{
		EnterRule_PUBLIC();
		EnterRule("PUBLIC", 2);
		TraceIn("PUBLIC", 2);
		try
		{
			int _type = PUBLIC;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:810:8: ( 'public' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:810:10: 'public'
			{
			DebugLocation(810, 10);
			Match("public"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PUBLIC", 2);
			LeaveRule("PUBLIC", 2);
			LeaveRule_PUBLIC();
		}
	}
	// $ANTLR end "PUBLIC"

	partial void EnterRule_STATIC();
	partial void LeaveRule_STATIC();

	// $ANTLR start "STATIC"
	[GrammarRule("STATIC")]
	private void mSTATIC()
	{
		EnterRule_STATIC();
		EnterRule("STATIC", 3);
		TraceIn("STATIC", 3);
		try
		{
			int _type = STATIC;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:811:8: ( 'static' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:811:10: 'static'
			{
			DebugLocation(811, 10);
			Match("static"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STATIC", 3);
			LeaveRule("STATIC", 3);
			LeaveRule_STATIC();
		}
	}
	// $ANTLR end "STATIC"

	partial void EnterRule_EXTENDS();
	partial void LeaveRule_EXTENDS();

	// $ANTLR start "EXTENDS"
	[GrammarRule("EXTENDS")]
	private void mEXTENDS()
	{
		EnterRule_EXTENDS();
		EnterRule("EXTENDS", 4);
		TraceIn("EXTENDS", 4);
		try
		{
			int _type = EXTENDS;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:812:9: ( 'extends' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:812:11: 'extends'
			{
			DebugLocation(812, 11);
			Match("extends"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EXTENDS", 4);
			LeaveRule("EXTENDS", 4);
			LeaveRule_EXTENDS();
		}
	}
	// $ANTLR end "EXTENDS"

	partial void EnterRule_VOID();
	partial void LeaveRule_VOID();

	// $ANTLR start "VOID"
	[GrammarRule("VOID")]
	private void mVOID()
	{
		EnterRule_VOID();
		EnterRule("VOID", 5);
		TraceIn("VOID", 5);
		try
		{
			int _type = VOID;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:813:6: ( 'void' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:813:8: 'void'
			{
			DebugLocation(813, 8);
			Match("void"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("VOID", 5);
			LeaveRule("VOID", 5);
			LeaveRule_VOID();
		}
	}
	// $ANTLR end "VOID"

	partial void EnterRule_INT();
	partial void LeaveRule_INT();

	// $ANTLR start "INT"
	[GrammarRule("INT")]
	private void mINT()
	{
		EnterRule_INT();
		EnterRule("INT", 6);
		TraceIn("INT", 6);
		try
		{
			int _type = INT;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:814:5: ( 'int' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:814:7: 'int'
			{
			DebugLocation(814, 7);
			Match("int"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("INT", 6);
			LeaveRule("INT", 6);
			LeaveRule_INT();
		}
	}
	// $ANTLR end "INT"

	partial void EnterRule_DOUBLE();
	partial void LeaveRule_DOUBLE();

	// $ANTLR start "DOUBLE"
	[GrammarRule("DOUBLE")]
	private void mDOUBLE()
	{
		EnterRule_DOUBLE();
		EnterRule("DOUBLE", 7);
		TraceIn("DOUBLE", 7);
		try
		{
			int _type = DOUBLE;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:815:8: ( 'double' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:815:10: 'double'
			{
			DebugLocation(815, 10);
			Match("double"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DOUBLE", 7);
			LeaveRule("DOUBLE", 7);
			LeaveRule_DOUBLE();
		}
	}
	// $ANTLR end "DOUBLE"

	partial void EnterRule_BOOLEAN();
	partial void LeaveRule_BOOLEAN();

	// $ANTLR start "BOOLEAN"
	[GrammarRule("BOOLEAN")]
	private void mBOOLEAN()
	{
		EnterRule_BOOLEAN();
		EnterRule("BOOLEAN", 8);
		TraceIn("BOOLEAN", 8);
		try
		{
			int _type = BOOLEAN;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:816:9: ( 'boolean' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:816:11: 'boolean'
			{
			DebugLocation(816, 11);
			Match("boolean"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BOOLEAN", 8);
			LeaveRule("BOOLEAN", 8);
			LeaveRule_BOOLEAN();
		}
	}
	// $ANTLR end "BOOLEAN"

	partial void EnterRule_IF();
	partial void LeaveRule_IF();

	// $ANTLR start "IF"
	[GrammarRule("IF")]
	private void mIF()
	{
		EnterRule_IF();
		EnterRule("IF", 9);
		TraceIn("IF", 9);
		try
		{
			int _type = IF;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:817:4: ( 'if' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:817:6: 'if'
			{
			DebugLocation(817, 6);
			Match("if"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IF", 9);
			LeaveRule("IF", 9);
			LeaveRule_IF();
		}
	}
	// $ANTLR end "IF"

	partial void EnterRule_ELSE();
	partial void LeaveRule_ELSE();

	// $ANTLR start "ELSE"
	[GrammarRule("ELSE")]
	private void mELSE()
	{
		EnterRule_ELSE();
		EnterRule("ELSE", 10);
		TraceIn("ELSE", 10);
		try
		{
			int _type = ELSE;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:818:6: ( 'else' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:818:8: 'else'
			{
			DebugLocation(818, 8);
			Match("else"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ELSE", 10);
			LeaveRule("ELSE", 10);
			LeaveRule_ELSE();
		}
	}
	// $ANTLR end "ELSE"

	partial void EnterRule_WHILE();
	partial void LeaveRule_WHILE();

	// $ANTLR start "WHILE"
	[GrammarRule("WHILE")]
	private void mWHILE()
	{
		EnterRule_WHILE();
		EnterRule("WHILE", 11);
		TraceIn("WHILE", 11);
		try
		{
			int _type = WHILE;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:819:7: ( 'while' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:819:9: 'while'
			{
			DebugLocation(819, 9);
			Match("while"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WHILE", 11);
			LeaveRule("WHILE", 11);
			LeaveRule_WHILE();
		}
	}
	// $ANTLR end "WHILE"

	partial void EnterRule_RETURN();
	partial void LeaveRule_RETURN();

	// $ANTLR start "RETURN"
	[GrammarRule("RETURN")]
	private void mRETURN()
	{
		EnterRule_RETURN();
		EnterRule("RETURN", 12);
		TraceIn("RETURN", 12);
		try
		{
			int _type = RETURN;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:820:8: ( 'return' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:820:10: 'return'
			{
			DebugLocation(820, 10);
			Match("return"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RETURN", 12);
			LeaveRule("RETURN", 12);
			LeaveRule_RETURN();
		}
	}
	// $ANTLR end "RETURN"

	partial void EnterRule_NULL();
	partial void LeaveRule_NULL();

	// $ANTLR start "NULL"
	[GrammarRule("NULL")]
	private void mNULL()
	{
		EnterRule_NULL();
		EnterRule("NULL", 13);
		TraceIn("NULL", 13);
		try
		{
			int _type = NULL;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:821:6: ( 'null' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:821:8: 'null'
			{
			DebugLocation(821, 8);
			Match("null"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NULL", 13);
			LeaveRule("NULL", 13);
			LeaveRule_NULL();
		}
	}
	// $ANTLR end "NULL"

	partial void EnterRule_TRUE();
	partial void LeaveRule_TRUE();

	// $ANTLR start "TRUE"
	[GrammarRule("TRUE")]
	private void mTRUE()
	{
		EnterRule_TRUE();
		EnterRule("TRUE", 14);
		TraceIn("TRUE", 14);
		try
		{
			int _type = TRUE;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:822:6: ( 'true' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:822:8: 'true'
			{
			DebugLocation(822, 8);
			Match("true"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TRUE", 14);
			LeaveRule("TRUE", 14);
			LeaveRule_TRUE();
		}
	}
	// $ANTLR end "TRUE"

	partial void EnterRule_FALSE();
	partial void LeaveRule_FALSE();

	// $ANTLR start "FALSE"
	[GrammarRule("FALSE")]
	private void mFALSE()
	{
		EnterRule_FALSE();
		EnterRule("FALSE", 15);
		TraceIn("FALSE", 15);
		try
		{
			int _type = FALSE;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:823:7: ( 'false' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:823:9: 'false'
			{
			DebugLocation(823, 9);
			Match("false"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FALSE", 15);
			LeaveRule("FALSE", 15);
			LeaveRule_FALSE();
		}
	}
	// $ANTLR end "FALSE"

	partial void EnterRule_THIS();
	partial void LeaveRule_THIS();

	// $ANTLR start "THIS"
	[GrammarRule("THIS")]
	private void mTHIS()
	{
		EnterRule_THIS();
		EnterRule("THIS", 16);
		TraceIn("THIS", 16);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:826:6: ( 'this' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:826:8: 'this'
			{
			DebugLocation(826, 8);
			Match("this"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("THIS", 16);
			LeaveRule("THIS", 16);
			LeaveRule_THIS();
		}
	}
	// $ANTLR end "THIS"

	partial void EnterRule_NEW();
	partial void LeaveRule_NEW();

	// $ANTLR start "NEW"
	[GrammarRule("NEW")]
	private void mNEW()
	{
		EnterRule_NEW();
		EnterRule("NEW", 17);
		TraceIn("NEW", 17);
		try
		{
			int _type = NEW;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:826:5: ( 'new' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:826:7: 'new'
			{
			DebugLocation(826, 7);
			Match("new"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NEW", 17);
			LeaveRule("NEW", 17);
			LeaveRule_NEW();
		}
	}
	// $ANTLR end "NEW"

	partial void EnterRule_STRING();
	partial void LeaveRule_STRING();

	// $ANTLR start "STRING"
	[GrammarRule("STRING")]
	private void mSTRING()
	{
		EnterRule_STRING();
		EnterRule("STRING", 18);
		TraceIn("STRING", 18);
		try
		{
			int _type = STRING;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:827:8: ( 'String' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:827:10: 'String'
			{
			DebugLocation(827, 10);
			Match("String"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STRING", 18);
			LeaveRule("STRING", 18);
			LeaveRule_STRING();
		}
	}
	// $ANTLR end "STRING"

	partial void EnterRule_MAIN();
	partial void LeaveRule_MAIN();

	// $ANTLR start "MAIN"
	[GrammarRule("MAIN")]
	private void mMAIN()
	{
		EnterRule_MAIN();
		EnterRule("MAIN", 19);
		TraceIn("MAIN", 19);
		try
		{
			int _type = MAIN;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:828:6: ( 'main' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:828:8: 'main'
			{
			DebugLocation(828, 8);
			Match("main"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MAIN", 19);
			LeaveRule("MAIN", 19);
			LeaveRule_MAIN();
		}
	}
	// $ANTLR end "MAIN"

	partial void EnterRule_PRINT();
	partial void LeaveRule_PRINT();

	// $ANTLR start "PRINT"
	[GrammarRule("PRINT")]
	private void mPRINT()
	{
		EnterRule_PRINT();
		EnterRule("PRINT", 20);
		TraceIn("PRINT", 20);
		try
		{
			int _type = PRINT;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:829:7: ( 'printf' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:829:9: 'printf'
			{
			DebugLocation(829, 9);
			Match("printf"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PRINT", 20);
			LeaveRule("PRINT", 20);
			LeaveRule_PRINT();
		}
	}
	// $ANTLR end "PRINT"

	partial void EnterRule_PRINT2();
	partial void LeaveRule_PRINT2();

	// $ANTLR start "PRINT2"
	[GrammarRule("PRINT2")]
	private void mPRINT2()
	{
		EnterRule_PRINT2();
		EnterRule("PRINT2", 21);
		TraceIn("PRINT2", 21);
		try
		{
			int _type = PRINT2;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:830:8: ( 'System.out.println' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:830:10: 'System.out.println'
			{
			DebugLocation(830, 10);
			Match("System.out.println"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PRINT2", 21);
			LeaveRule("PRINT2", 21);
			LeaveRule_PRINT2();
		}
	}
	// $ANTLR end "PRINT2"

	partial void EnterRule_LENGTH();
	partial void LeaveRule_LENGTH();

	// $ANTLR start "LENGTH"
	[GrammarRule("LENGTH")]
	private void mLENGTH()
	{
		EnterRule_LENGTH();
		EnterRule("LENGTH", 22);
		TraceIn("LENGTH", 22);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:834:8: ( 'length' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:834:10: 'length'
			{
			DebugLocation(834, 10);
			Match("length"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("LENGTH", 22);
			LeaveRule("LENGTH", 22);
			LeaveRule_LENGTH();
		}
	}
	// $ANTLR end "LENGTH"

	partial void EnterRule_PLUS();
	partial void LeaveRule_PLUS();

	// $ANTLR start "PLUS"
	[GrammarRule("PLUS")]
	private void mPLUS()
	{
		EnterRule_PLUS();
		EnterRule("PLUS", 23);
		TraceIn("PLUS", 23);
		try
		{
			int _type = PLUS;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:844:9: ( '+' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:844:11: '+'
			{
			DebugLocation(844, 11);
			Match('+'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PLUS", 23);
			LeaveRule("PLUS", 23);
			LeaveRule_PLUS();
		}
	}
	// $ANTLR end "PLUS"

	partial void EnterRule_MINUS();
	partial void LeaveRule_MINUS();

	// $ANTLR start "MINUS"
	[GrammarRule("MINUS")]
	private void mMINUS()
	{
		EnterRule_MINUS();
		EnterRule("MINUS", 24);
		TraceIn("MINUS", 24);
		try
		{
			int _type = MINUS;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:845:9: ( '-' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:845:11: '-'
			{
			DebugLocation(845, 11);
			Match('-'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MINUS", 24);
			LeaveRule("MINUS", 24);
			LeaveRule_MINUS();
		}
	}
	// $ANTLR end "MINUS"

	partial void EnterRule_STAR();
	partial void LeaveRule_STAR();

	// $ANTLR start "STAR"
	[GrammarRule("STAR")]
	private void mSTAR()
	{
		EnterRule_STAR();
		EnterRule("STAR", 25);
		TraceIn("STAR", 25);
		try
		{
			int _type = STAR;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:846:9: ( '*' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:846:11: '*'
			{
			DebugLocation(846, 11);
			Match('*'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STAR", 25);
			LeaveRule("STAR", 25);
			LeaveRule_STAR();
		}
	}
	// $ANTLR end "STAR"

	partial void EnterRule_DIV();
	partial void LeaveRule_DIV();

	// $ANTLR start "DIV"
	[GrammarRule("DIV")]
	private void mDIV()
	{
		EnterRule_DIV();
		EnterRule("DIV", 26);
		TraceIn("DIV", 26);
		try
		{
			int _type = DIV;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:847:9: ( '/' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:847:11: '/'
			{
			DebugLocation(847, 11);
			Match('/'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DIV", 26);
			LeaveRule("DIV", 26);
			LeaveRule_DIV();
		}
	}
	// $ANTLR end "DIV"

	partial void EnterRule_LESS();
	partial void LeaveRule_LESS();

	// $ANTLR start "LESS"
	[GrammarRule("LESS")]
	private void mLESS()
	{
		EnterRule_LESS();
		EnterRule("LESS", 27);
		TraceIn("LESS", 27);
		try
		{
			int _type = LESS;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:848:9: ( '<' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:848:11: '<'
			{
			DebugLocation(848, 11);
			Match('<'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LESS", 27);
			LeaveRule("LESS", 27);
			LeaveRule_LESS();
		}
	}
	// $ANTLR end "LESS"

	partial void EnterRule_LESSEQ();
	partial void LeaveRule_LESSEQ();

	// $ANTLR start "LESSEQ"
	[GrammarRule("LESSEQ")]
	private void mLESSEQ()
	{
		EnterRule_LESSEQ();
		EnterRule("LESSEQ", 28);
		TraceIn("LESSEQ", 28);
		try
		{
			int _type = LESSEQ;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:849:9: ( '<=' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:849:11: '<='
			{
			DebugLocation(849, 11);
			Match("<="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LESSEQ", 28);
			LeaveRule("LESSEQ", 28);
			LeaveRule_LESSEQ();
		}
	}
	// $ANTLR end "LESSEQ"

	partial void EnterRule_MOREEQ();
	partial void LeaveRule_MOREEQ();

	// $ANTLR start "MOREEQ"
	[GrammarRule("MOREEQ")]
	private void mMOREEQ()
	{
		EnterRule_MOREEQ();
		EnterRule("MOREEQ", 29);
		TraceIn("MOREEQ", 29);
		try
		{
			int _type = MOREEQ;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:850:9: ( '>=' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:850:11: '>='
			{
			DebugLocation(850, 11);
			Match(">="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MOREEQ", 29);
			LeaveRule("MOREEQ", 29);
			LeaveRule_MOREEQ();
		}
	}
	// $ANTLR end "MOREEQ"

	partial void EnterRule_MORE();
	partial void LeaveRule_MORE();

	// $ANTLR start "MORE"
	[GrammarRule("MORE")]
	private void mMORE()
	{
		EnterRule_MORE();
		EnterRule("MORE", 30);
		TraceIn("MORE", 30);
		try
		{
			int _type = MORE;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:851:9: ( '>' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:851:11: '>'
			{
			DebugLocation(851, 11);
			Match('>'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MORE", 30);
			LeaveRule("MORE", 30);
			LeaveRule_MORE();
		}
	}
	// $ANTLR end "MORE"

	partial void EnterRule_EQUAL();
	partial void LeaveRule_EQUAL();

	// $ANTLR start "EQUAL"
	[GrammarRule("EQUAL")]
	private void mEQUAL()
	{
		EnterRule_EQUAL();
		EnterRule("EQUAL", 31);
		TraceIn("EQUAL", 31);
		try
		{
			int _type = EQUAL;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:852:9: ( '==' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:852:11: '=='
			{
			DebugLocation(852, 11);
			Match("=="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EQUAL", 31);
			LeaveRule("EQUAL", 31);
			LeaveRule_EQUAL();
		}
	}
	// $ANTLR end "EQUAL"

	partial void EnterRule_NEQUAL();
	partial void LeaveRule_NEQUAL();

	// $ANTLR start "NEQUAL"
	[GrammarRule("NEQUAL")]
	private void mNEQUAL()
	{
		EnterRule_NEQUAL();
		EnterRule("NEQUAL", 32);
		TraceIn("NEQUAL", 32);
		try
		{
			int _type = NEQUAL;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:853:9: ( '!=' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:853:11: '!='
			{
			DebugLocation(853, 11);
			Match("!="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NEQUAL", 32);
			LeaveRule("NEQUAL", 32);
			LeaveRule_NEQUAL();
		}
	}
	// $ANTLR end "NEQUAL"

	partial void EnterRule_LAND();
	partial void LeaveRule_LAND();

	// $ANTLR start "LAND"
	[GrammarRule("LAND")]
	private void mLAND()
	{
		EnterRule_LAND();
		EnterRule("LAND", 33);
		TraceIn("LAND", 33);
		try
		{
			int _type = LAND;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:854:9: ( '&&' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:854:11: '&&'
			{
			DebugLocation(854, 11);
			Match("&&"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LAND", 33);
			LeaveRule("LAND", 33);
			LeaveRule_LAND();
		}
	}
	// $ANTLR end "LAND"

	partial void EnterRule_LOR();
	partial void LeaveRule_LOR();

	// $ANTLR start "LOR"
	[GrammarRule("LOR")]
	private void mLOR()
	{
		EnterRule_LOR();
		EnterRule("LOR", 34);
		TraceIn("LOR", 34);
		try
		{
			int _type = LOR;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:855:9: ( '||' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:855:11: '||'
			{
			DebugLocation(855, 11);
			Match("||"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LOR", 34);
			LeaveRule("LOR", 34);
			LeaveRule_LOR();
		}
	}
	// $ANTLR end "LOR"

	partial void EnterRule_LNOT();
	partial void LeaveRule_LNOT();

	// $ANTLR start "LNOT"
	[GrammarRule("LNOT")]
	private void mLNOT()
	{
		EnterRule_LNOT();
		EnterRule("LNOT", 35);
		TraceIn("LNOT", 35);
		try
		{
			int _type = LNOT;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:856:9: ( '!' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:856:11: '!'
			{
			DebugLocation(856, 11);
			Match('!'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LNOT", 35);
			LeaveRule("LNOT", 35);
			LeaveRule_LNOT();
		}
	}
	// $ANTLR end "LNOT"

	partial void EnterRule_SEMI();
	partial void LeaveRule_SEMI();

	// $ANTLR start "SEMI"
	[GrammarRule("SEMI")]
	private void mSEMI()
	{
		EnterRule_SEMI();
		EnterRule("SEMI", 36);
		TraceIn("SEMI", 36);
		try
		{
			int _type = SEMI;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:859:9: ( ';' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:859:11: ';'
			{
			DebugLocation(859, 11);
			Match(';'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SEMI", 36);
			LeaveRule("SEMI", 36);
			LeaveRule_SEMI();
		}
	}
	// $ANTLR end "SEMI"

	partial void EnterRule_DOT();
	partial void LeaveRule_DOT();

	// $ANTLR start "DOT"
	[GrammarRule("DOT")]
	private void mDOT()
	{
		EnterRule_DOT();
		EnterRule("DOT", 37);
		TraceIn("DOT", 37);
		try
		{
			int _type = DOT;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:860:9: ( '.' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:860:11: '.'
			{
			DebugLocation(860, 11);
			Match('.'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DOT", 37);
			LeaveRule("DOT", 37);
			LeaveRule_DOT();
		}
	}
	// $ANTLR end "DOT"

	partial void EnterRule_COMMA();
	partial void LeaveRule_COMMA();

	// $ANTLR start "COMMA"
	[GrammarRule("COMMA")]
	private void mCOMMA()
	{
		EnterRule_COMMA();
		EnterRule("COMMA", 38);
		TraceIn("COMMA", 38);
		try
		{
			int _type = COMMA;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:861:9: ( ',' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:861:11: ','
			{
			DebugLocation(861, 11);
			Match(','); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COMMA", 38);
			LeaveRule("COMMA", 38);
			LeaveRule_COMMA();
		}
	}
	// $ANTLR end "COMMA"

	partial void EnterRule_ASSIGN();
	partial void LeaveRule_ASSIGN();

	// $ANTLR start "ASSIGN"
	[GrammarRule("ASSIGN")]
	private void mASSIGN()
	{
		EnterRule_ASSIGN();
		EnterRule("ASSIGN", 39);
		TraceIn("ASSIGN", 39);
		try
		{
			int _type = ASSIGN;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:862:9: ( '=' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:862:11: '='
			{
			DebugLocation(862, 11);
			Match('='); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ASSIGN", 39);
			LeaveRule("ASSIGN", 39);
			LeaveRule_ASSIGN();
		}
	}
	// $ANTLR end "ASSIGN"

	partial void EnterRule_LPAREN();
	partial void LeaveRule_LPAREN();

	// $ANTLR start "LPAREN"
	[GrammarRule("LPAREN")]
	private void mLPAREN()
	{
		EnterRule_LPAREN();
		EnterRule("LPAREN", 40);
		TraceIn("LPAREN", 40);
		try
		{
			int _type = LPAREN;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:863:9: ( '(' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:863:11: '('
			{
			DebugLocation(863, 11);
			Match('('); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LPAREN", 40);
			LeaveRule("LPAREN", 40);
			LeaveRule_LPAREN();
		}
	}
	// $ANTLR end "LPAREN"

	partial void EnterRule_RPAREN();
	partial void LeaveRule_RPAREN();

	// $ANTLR start "RPAREN"
	[GrammarRule("RPAREN")]
	private void mRPAREN()
	{
		EnterRule_RPAREN();
		EnterRule("RPAREN", 41);
		TraceIn("RPAREN", 41);
		try
		{
			int _type = RPAREN;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:864:9: ( ')' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:864:11: ')'
			{
			DebugLocation(864, 11);
			Match(')'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RPAREN", 41);
			LeaveRule("RPAREN", 41);
			LeaveRule_RPAREN();
		}
	}
	// $ANTLR end "RPAREN"

	partial void EnterRule_LCURLY();
	partial void LeaveRule_LCURLY();

	// $ANTLR start "LCURLY"
	[GrammarRule("LCURLY")]
	private void mLCURLY()
	{
		EnterRule_LCURLY();
		EnterRule("LCURLY", 42);
		TraceIn("LCURLY", 42);
		try
		{
			int _type = LCURLY;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:865:9: ( '{' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:865:11: '{'
			{
			DebugLocation(865, 11);
			Match('{'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LCURLY", 42);
			LeaveRule("LCURLY", 42);
			LeaveRule_LCURLY();
		}
	}
	// $ANTLR end "LCURLY"

	partial void EnterRule_RCURLY();
	partial void LeaveRule_RCURLY();

	// $ANTLR start "RCURLY"
	[GrammarRule("RCURLY")]
	private void mRCURLY()
	{
		EnterRule_RCURLY();
		EnterRule("RCURLY", 43);
		TraceIn("RCURLY", 43);
		try
		{
			int _type = RCURLY;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:866:9: ( '}' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:866:11: '}'
			{
			DebugLocation(866, 11);
			Match('}'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RCURLY", 43);
			LeaveRule("RCURLY", 43);
			LeaveRule_RCURLY();
		}
	}
	// $ANTLR end "RCURLY"

	partial void EnterRule_LBRACK();
	partial void LeaveRule_LBRACK();

	// $ANTLR start "LBRACK"
	[GrammarRule("LBRACK")]
	private void mLBRACK()
	{
		EnterRule_LBRACK();
		EnterRule("LBRACK", 44);
		TraceIn("LBRACK", 44);
		try
		{
			int _type = LBRACK;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:867:9: ( '[' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:867:11: '['
			{
			DebugLocation(867, 11);
			Match('['); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LBRACK", 44);
			LeaveRule("LBRACK", 44);
			LeaveRule_LBRACK();
		}
	}
	// $ANTLR end "LBRACK"

	partial void EnterRule_RBRACK();
	partial void LeaveRule_RBRACK();

	// $ANTLR start "RBRACK"
	[GrammarRule("RBRACK")]
	private void mRBRACK()
	{
		EnterRule_RBRACK();
		EnterRule("RBRACK", 45);
		TraceIn("RBRACK", 45);
		try
		{
			int _type = RBRACK;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:868:9: ( ']' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:868:11: ']'
			{
			DebugLocation(868, 11);
			Match(']'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RBRACK", 45);
			LeaveRule("RBRACK", 45);
			LeaveRule_RBRACK();
		}
	}
	// $ANTLR end "RBRACK"

	partial void EnterRule_LETTER();
	partial void LeaveRule_LETTER();

	// $ANTLR start "LETTER"
	[GrammarRule("LETTER")]
	private void mLETTER()
	{
		EnterRule_LETTER();
		EnterRule("LETTER", 46);
		TraceIn("LETTER", 46);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:874:7: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:
			{
			DebugLocation(874, 7);
			if ((input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;}


			}

		}
		finally
		{
			TraceOut("LETTER", 46);
			LeaveRule("LETTER", 46);
			LeaveRule_LETTER();
		}
	}
	// $ANTLR end "LETTER"

	partial void EnterRule_DIGIT();
	partial void LeaveRule_DIGIT();

	// $ANTLR start "DIGIT"
	[GrammarRule("DIGIT")]
	private void mDIGIT()
	{
		EnterRule_DIGIT();
		EnterRule("DIGIT", 47);
		TraceIn("DIGIT", 47);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:879:6: ( ( '0' .. '9' ) )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:
			{
			DebugLocation(879, 6);
			if ((input.LA(1)>='0' && input.LA(1)<='9'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;}


			}

		}
		finally
		{
			TraceOut("DIGIT", 47);
			LeaveRule("DIGIT", 47);
			LeaveRule_DIGIT();
		}
	}
	// $ANTLR end "DIGIT"

	partial void EnterRule_ID();
	partial void LeaveRule_ID();

	// $ANTLR start "ID"
	[GrammarRule("ID")]
	private void mID()
	{
		EnterRule_ID();
		EnterRule("ID", 48);
		TraceIn("ID", 48);
		try
		{
			int _type = ID;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:885:2: ( ( 'System.out.println' ~ ( 'a' .. 'z' | 'A' .. 'Z' | DIGIT ) )=> 'System.out.println' | ( ( LETTER ) ( LETTER | DIGIT )* ) )
			int alt2=2;
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0=='S'))
			{
				int LA2_1 = input.LA(2);

				if ((LA2_1=='y'))
				{
					int LA2_3 = input.LA(3);

					if ((LA2_3=='s'))
					{
						int LA2_4 = input.LA(4);

						if ((LA2_4=='t'))
						{
							int LA2_5 = input.LA(5);

							if ((LA2_5=='e'))
							{
								int LA2_6 = input.LA(6);

								if ((LA2_6=='m'))
								{
									int LA2_7 = input.LA(7);

									if ((LA2_7=='.') && (EvaluatePredicate(synpred1_MiniJava_fragment)))
									{
										alt2 = 1;
									}
									else
									{
										alt2 = 2;}
								}
								else
								{
									alt2 = 2;}
							}
							else
							{
								alt2 = 2;}
						}
						else
						{
							alt2 = 2;}
					}
					else
					{
						alt2 = 2;}
				}
				else
				{
					alt2 = 2;}
			}
			else if (((LA2_0>='A' && LA2_0<='R')||(LA2_0>='T' && LA2_0<='Z')||LA2_0=='_'||(LA2_0>='a' && LA2_0<='z')))
			{
				alt2 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:893:3: ( 'System.out.println' ~ ( 'a' .. 'z' | 'A' .. 'Z' | DIGIT ) )=> 'System.out.println'
				{
				DebugLocation(893, 61);
				Match("System.out.println"); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:895:3: ( ( LETTER ) ( LETTER | DIGIT )* )
				{
				DebugLocation(895, 3);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:895:3: ( ( LETTER ) ( LETTER | DIGIT )* )
				DebugEnterAlt(1);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:895:6: ( LETTER ) ( LETTER | DIGIT )*
				{
				DebugLocation(895, 6);
				input.Consume();
				state.failed=false;
				DebugLocation(895, 15);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:895:15: ( LETTER | DIGIT )*
				try { DebugEnterSubRule(1);
				while (true)
				{
					int alt1=2;
					try { DebugEnterDecision(1, false);
					int LA1_0 = input.LA(1);

					if (((LA1_0>='0' && LA1_0<='9')||(LA1_0>='A' && LA1_0<='Z')||LA1_0=='_'||(LA1_0>='a' && LA1_0<='z')))
					{
						alt1 = 1;
					}


					} finally { DebugExitDecision(1); }
					switch ( alt1 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:
						{
						DebugLocation(895, 15);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						goto loop1;
					}
				}

				loop1:
					;

				} finally { DebugExitSubRule(1); }


				}


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ID", 48);
			LeaveRule("ID", 48);
			LeaveRule_ID();
		}
	}
	// $ANTLR end "ID"

	partial void EnterRule_INTEGER();
	partial void LeaveRule_INTEGER();

	// $ANTLR start "INTEGER"
	[GrammarRule("INTEGER")]
	private void mINTEGER()
	{
		EnterRule_INTEGER();
		EnterRule("INTEGER", 49);
		TraceIn("INTEGER", 49);
		try
		{
			int _type = INTEGER;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:904:2: ( ( DIGIT )+ )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:905:3: ( DIGIT )+
			{
			DebugLocation(905, 3);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:905:3: ( DIGIT )+
			int cnt3=0;
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if (((LA3_0>='0' && LA3_0<='9')))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch (alt3)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:
					{
					DebugLocation(905, 3);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt3 >= 1)
						goto loop3;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee3 = new EarlyExitException( 3, input );
					DebugRecognitionException(eee3);
					throw eee3;
				}
				cnt3++;
			}
			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("INTEGER", 49);
			LeaveRule("INTEGER", 49);
			LeaveRule_INTEGER();
		}
	}
	// $ANTLR end "INTEGER"

	partial void EnterRule_FLOAT();
	partial void LeaveRule_FLOAT();

	// $ANTLR start "FLOAT"
	[GrammarRule("FLOAT")]
	private void mFLOAT()
	{
		EnterRule_FLOAT();
		EnterRule("FLOAT", 50);
		TraceIn("FLOAT", 50);
		try
		{
			int _type = FLOAT;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:910:5: ( ( DIGIT )+ '.' ( DIGIT )* ( EXPONENT )? | '.' ( DIGIT )+ ( EXPONENT )? | ( DIGIT )+ EXPONENT )
			int alt10=3;
			try { DebugEnterDecision(10, false);
			try
			{
				alt10 = dfa10.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:911:3: ( DIGIT )+ '.' ( DIGIT )* ( EXPONENT )?
				{
				DebugLocation(911, 3);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:911:3: ( DIGIT )+
				int cnt4=0;
				try { DebugEnterSubRule(4);
				while (true)
				{
					int alt4=2;
					try { DebugEnterDecision(4, false);
					int LA4_0 = input.LA(1);

					if (((LA4_0>='0' && LA4_0<='9')))
					{
						alt4 = 1;
					}


					} finally { DebugExitDecision(4); }
					switch (alt4)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:
						{
						DebugLocation(911, 3);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						if (cnt4 >= 1)
							goto loop4;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee4 = new EarlyExitException( 4, input );
						DebugRecognitionException(eee4);
						throw eee4;
					}
					cnt4++;
				}
				loop4:
					;

				} finally { DebugExitSubRule(4); }

				DebugLocation(911, 12);
				Match('.'); if (state.failed) return;
				DebugLocation(911, 16);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:911:16: ( DIGIT )*
				try { DebugEnterSubRule(5);
				while (true)
				{
					int alt5=2;
					try { DebugEnterDecision(5, false);
					int LA5_0 = input.LA(1);

					if (((LA5_0>='0' && LA5_0<='9')))
					{
						alt5 = 1;
					}


					} finally { DebugExitDecision(5); }
					switch ( alt5 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:
						{
						DebugLocation(911, 16);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						goto loop5;
					}
				}

				loop5:
					;

				} finally { DebugExitSubRule(5); }

				DebugLocation(911, 25);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:911:25: ( EXPONENT )?
				int alt6=2;
				try { DebugEnterSubRule(6);
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0=='E'||LA6_0=='e'))
				{
					alt6 = 1;
				}
				} finally { DebugExitDecision(6); }
				switch (alt6)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:911:25: EXPONENT
					{
					DebugLocation(911, 25);
					mEXPONENT(); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(6); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:913:3: '.' ( DIGIT )+ ( EXPONENT )?
				{
				DebugLocation(913, 3);
				Match('.'); if (state.failed) return;
				DebugLocation(913, 7);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:913:7: ( DIGIT )+
				int cnt7=0;
				try { DebugEnterSubRule(7);
				while (true)
				{
					int alt7=2;
					try { DebugEnterDecision(7, false);
					int LA7_0 = input.LA(1);

					if (((LA7_0>='0' && LA7_0<='9')))
					{
						alt7 = 1;
					}


					} finally { DebugExitDecision(7); }
					switch (alt7)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:
						{
						DebugLocation(913, 7);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						if (cnt7 >= 1)
							goto loop7;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee7 = new EarlyExitException( 7, input );
						DebugRecognitionException(eee7);
						throw eee7;
					}
					cnt7++;
				}
				loop7:
					;

				} finally { DebugExitSubRule(7); }

				DebugLocation(913, 16);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:913:16: ( EXPONENT )?
				int alt8=2;
				try { DebugEnterSubRule(8);
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0=='E'||LA8_0=='e'))
				{
					alt8 = 1;
				}
				} finally { DebugExitDecision(8); }
				switch (alt8)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:913:16: EXPONENT
					{
					DebugLocation(913, 16);
					mEXPONENT(); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(8); }


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:915:3: ( DIGIT )+ EXPONENT
				{
				DebugLocation(915, 3);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:915:3: ( DIGIT )+
				int cnt9=0;
				try { DebugEnterSubRule(9);
				while (true)
				{
					int alt9=2;
					try { DebugEnterDecision(9, false);
					int LA9_0 = input.LA(1);

					if (((LA9_0>='0' && LA9_0<='9')))
					{
						alt9 = 1;
					}


					} finally { DebugExitDecision(9); }
					switch (alt9)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:
						{
						DebugLocation(915, 3);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						if (cnt9 >= 1)
							goto loop9;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee9 = new EarlyExitException( 9, input );
						DebugRecognitionException(eee9);
						throw eee9;
					}
					cnt9++;
				}
				loop9:
					;

				} finally { DebugExitSubRule(9); }

				DebugLocation(915, 12);
				mEXPONENT(); if (state.failed) return;

				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FLOAT", 50);
			LeaveRule("FLOAT", 50);
			LeaveRule_FLOAT();
		}
	}
	// $ANTLR end "FLOAT"

	partial void EnterRule_EXPONENT();
	partial void LeaveRule_EXPONENT();

	// $ANTLR start "EXPONENT"
	[GrammarRule("EXPONENT")]
	private void mEXPONENT()
	{
		EnterRule_EXPONENT();
		EnterRule("EXPONENT", 51);
		TraceIn("EXPONENT", 51);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:921:10: ( ( 'e' | 'E' ) ( '+' | '-' )? ( DIGIT )+ )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:921:12: ( 'e' | 'E' ) ( '+' | '-' )? ( DIGIT )+
			{
			DebugLocation(921, 12);
			if (input.LA(1)=='E'||input.LA(1)=='e')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;}

			DebugLocation(921, 22);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:921:22: ( '+' | '-' )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_0 = input.LA(1);

			if ((LA11_0=='+'||LA11_0=='-'))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:
				{
				DebugLocation(921, 22);
				input.Consume();
				state.failed=false;

				}
				break;

			}
			} finally { DebugExitSubRule(11); }

			DebugLocation(921, 33);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:921:33: ( DIGIT )+
			int cnt12=0;
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if (((LA12_0>='0' && LA12_0<='9')))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch (alt12)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:
					{
					DebugLocation(921, 33);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt12 >= 1)
						goto loop12;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee12 = new EarlyExitException( 12, input );
					DebugRecognitionException(eee12);
					throw eee12;
				}
				cnt12++;
			}
			loop12:
				;

			} finally { DebugExitSubRule(12); }


			}

		}
		finally
		{
			TraceOut("EXPONENT", 51);
			LeaveRule("EXPONENT", 51);
			LeaveRule_EXPONENT();
		}
	}
	// $ANTLR end "EXPONENT"

	partial void EnterRule_WHITESPACE();
	partial void LeaveRule_WHITESPACE();

	// $ANTLR start "WHITESPACE"
	[GrammarRule("WHITESPACE")]
	private void mWHITESPACE()
	{
		EnterRule_WHITESPACE();
		EnterRule("WHITESPACE", 52);
		TraceIn("WHITESPACE", 52);
		try
		{
			int _type = WHITESPACE;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:924:2: ( ( ' ' | '\\t' | '\\r' | '\\n' ) )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:925:5: ( ' ' | '\\t' | '\\r' | '\\n' )
			{
			DebugLocation(925, 5);
			if ((input.LA(1)>='\t' && input.LA(1)<='\n')||input.LA(1)=='\r'||input.LA(1)==' ')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;}

			DebugLocation(929, 11);
			if (state.backtracking == 0)
			{
				_channel=HIDDEN;
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WHITESPACE", 52);
			LeaveRule("WHITESPACE", 52);
			LeaveRule_WHITESPACE();
		}
	}
	// $ANTLR end "WHITESPACE"

	partial void EnterRule_LINE_COMMENT();
	partial void LeaveRule_LINE_COMMENT();

	// $ANTLR start "LINE_COMMENT"
	[GrammarRule("LINE_COMMENT")]
	private void mLINE_COMMENT()
	{
		EnterRule_LINE_COMMENT();
		EnterRule("LINE_COMMENT", 53);
		TraceIn("LINE_COMMENT", 53);
		try
		{
			int _type = LINE_COMMENT;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:933:2: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:934:3: '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n'
			{
			DebugLocation(934, 3);
			Match("//"); if (state.failed) return;

			DebugLocation(934, 8);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:934:8: (~ ( '\\n' | '\\r' ) )*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, false);
				int LA13_0 = input.LA(1);

				if (((LA13_0>='\u0000' && LA13_0<='\t')||(LA13_0>='\u000B' && LA13_0<='\f')||(LA13_0>='\u000E' && LA13_0<='\uFFFF')))
				{
					alt13 = 1;
				}


				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:
					{
					DebugLocation(934, 8);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }

			DebugLocation(934, 22);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:934:22: ( '\\r' )?
			int alt14=2;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, false);
			int LA14_0 = input.LA(1);

			if ((LA14_0=='\r'))
			{
				alt14 = 1;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:934:22: '\\r'
				{
				DebugLocation(934, 22);
				Match('\r'); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(14); }

			DebugLocation(934, 28);
			Match('\n'); if (state.failed) return;
			DebugLocation(934, 33);
			if (state.backtracking == 0)
			{
				_channel=HIDDEN;
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LINE_COMMENT", 53);
			LeaveRule("LINE_COMMENT", 53);
			LeaveRule_LINE_COMMENT();
		}
	}
	// $ANTLR end "LINE_COMMENT"

	partial void EnterRule_BLOCK_COMMENT();
	partial void LeaveRule_BLOCK_COMMENT();

	// $ANTLR start "BLOCK_COMMENT"
	[GrammarRule("BLOCK_COMMENT")]
	private void mBLOCK_COMMENT()
	{
		EnterRule_BLOCK_COMMENT();
		EnterRule("BLOCK_COMMENT", 54);
		TraceIn("BLOCK_COMMENT", 54);
		try
		{
			int _type = BLOCK_COMMENT;
			int _channel = DefaultTokenChannel;
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:938:2: ( '/*' ( options {greedy=false; } : . )* '*/' )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:939:3: '/*' ( options {greedy=false; } : . )* '*/'
			{
			DebugLocation(939, 3);
			Match("/*"); if (state.failed) return;

			DebugLocation(939, 8);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:939:8: ( options {greedy=false; } : . )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_0 = input.LA(1);

				if ((LA15_0=='*'))
				{
					int LA15_1 = input.LA(2);

					if ((LA15_1=='/'))
					{
						alt15 = 2;
					}
					else if (((LA15_1>='\u0000' && LA15_1<='.')||(LA15_1>='0' && LA15_1<='\uFFFF')))
					{
						alt15 = 1;
					}


				}
				else if (((LA15_0>='\u0000' && LA15_0<=')')||(LA15_0>='+' && LA15_0<='\uFFFF')))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:939:36: .
					{
					DebugLocation(939, 36);
					MatchAny(); if (state.failed) return;

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }

			DebugLocation(939, 41);
			Match("*/"); if (state.failed) return;

			DebugLocation(939, 46);
			if (state.backtracking == 0)
			{
				_channel=HIDDEN;
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BLOCK_COMMENT", 54);
			LeaveRule("BLOCK_COMMENT", 54);
			LeaveRule_BLOCK_COMMENT();
		}
	}
	// $ANTLR end "BLOCK_COMMENT"

	public override void mTokens()
	{
		// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:8: ( CLASS | PUBLIC | STATIC | EXTENDS | VOID | INT | DOUBLE | BOOLEAN | IF | ELSE | WHILE | RETURN | NULL | TRUE | FALSE | NEW | STRING | MAIN | PRINT | PRINT2 | PLUS | MINUS | STAR | DIV | LESS | LESSEQ | MOREEQ | MORE | EQUAL | NEQUAL | LAND | LOR | LNOT | SEMI | DOT | COMMA | ASSIGN | LPAREN | RPAREN | LCURLY | RCURLY | LBRACK | RBRACK | ID | INTEGER | FLOAT | WHITESPACE | LINE_COMMENT | BLOCK_COMMENT )
		int alt16=49;
		try { DebugEnterDecision(16, false);
		try
		{
			alt16 = dfa16.Predict(input);
		}
		catch (NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
			throw;
		}
		} finally { DebugExitDecision(16); }
		switch (alt16)
		{
		case 1:
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:10: CLASS
			{
			DebugLocation(1, 10);
			mCLASS(); if (state.failed) return;

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:16: PUBLIC
			{
			DebugLocation(1, 16);
			mPUBLIC(); if (state.failed) return;

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:23: STATIC
			{
			DebugLocation(1, 23);
			mSTATIC(); if (state.failed) return;

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:30: EXTENDS
			{
			DebugLocation(1, 30);
			mEXTENDS(); if (state.failed) return;

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:38: VOID
			{
			DebugLocation(1, 38);
			mVOID(); if (state.failed) return;

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:43: INT
			{
			DebugLocation(1, 43);
			mINT(); if (state.failed) return;

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:47: DOUBLE
			{
			DebugLocation(1, 47);
			mDOUBLE(); if (state.failed) return;

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:54: BOOLEAN
			{
			DebugLocation(1, 54);
			mBOOLEAN(); if (state.failed) return;

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:62: IF
			{
			DebugLocation(1, 62);
			mIF(); if (state.failed) return;

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:65: ELSE
			{
			DebugLocation(1, 65);
			mELSE(); if (state.failed) return;

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:70: WHILE
			{
			DebugLocation(1, 70);
			mWHILE(); if (state.failed) return;

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:76: RETURN
			{
			DebugLocation(1, 76);
			mRETURN(); if (state.failed) return;

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:83: NULL
			{
			DebugLocation(1, 83);
			mNULL(); if (state.failed) return;

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:88: TRUE
			{
			DebugLocation(1, 88);
			mTRUE(); if (state.failed) return;

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:93: FALSE
			{
			DebugLocation(1, 93);
			mFALSE(); if (state.failed) return;

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:99: NEW
			{
			DebugLocation(1, 99);
			mNEW(); if (state.failed) return;

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:103: STRING
			{
			DebugLocation(1, 103);
			mSTRING(); if (state.failed) return;

			}
			break;
		case 18:
			DebugEnterAlt(18);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:110: MAIN
			{
			DebugLocation(1, 110);
			mMAIN(); if (state.failed) return;

			}
			break;
		case 19:
			DebugEnterAlt(19);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:115: PRINT
			{
			DebugLocation(1, 115);
			mPRINT(); if (state.failed) return;

			}
			break;
		case 20:
			DebugEnterAlt(20);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:121: PRINT2
			{
			DebugLocation(1, 121);
			mPRINT2(); if (state.failed) return;

			}
			break;
		case 21:
			DebugEnterAlt(21);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:128: PLUS
			{
			DebugLocation(1, 128);
			mPLUS(); if (state.failed) return;

			}
			break;
		case 22:
			DebugEnterAlt(22);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:133: MINUS
			{
			DebugLocation(1, 133);
			mMINUS(); if (state.failed) return;

			}
			break;
		case 23:
			DebugEnterAlt(23);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:139: STAR
			{
			DebugLocation(1, 139);
			mSTAR(); if (state.failed) return;

			}
			break;
		case 24:
			DebugEnterAlt(24);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:144: DIV
			{
			DebugLocation(1, 144);
			mDIV(); if (state.failed) return;

			}
			break;
		case 25:
			DebugEnterAlt(25);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:148: LESS
			{
			DebugLocation(1, 148);
			mLESS(); if (state.failed) return;

			}
			break;
		case 26:
			DebugEnterAlt(26);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:153: LESSEQ
			{
			DebugLocation(1, 153);
			mLESSEQ(); if (state.failed) return;

			}
			break;
		case 27:
			DebugEnterAlt(27);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:160: MOREEQ
			{
			DebugLocation(1, 160);
			mMOREEQ(); if (state.failed) return;

			}
			break;
		case 28:
			DebugEnterAlt(28);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:167: MORE
			{
			DebugLocation(1, 167);
			mMORE(); if (state.failed) return;

			}
			break;
		case 29:
			DebugEnterAlt(29);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:172: EQUAL
			{
			DebugLocation(1, 172);
			mEQUAL(); if (state.failed) return;

			}
			break;
		case 30:
			DebugEnterAlt(30);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:178: NEQUAL
			{
			DebugLocation(1, 178);
			mNEQUAL(); if (state.failed) return;

			}
			break;
		case 31:
			DebugEnterAlt(31);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:185: LAND
			{
			DebugLocation(1, 185);
			mLAND(); if (state.failed) return;

			}
			break;
		case 32:
			DebugEnterAlt(32);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:190: LOR
			{
			DebugLocation(1, 190);
			mLOR(); if (state.failed) return;

			}
			break;
		case 33:
			DebugEnterAlt(33);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:194: LNOT
			{
			DebugLocation(1, 194);
			mLNOT(); if (state.failed) return;

			}
			break;
		case 34:
			DebugEnterAlt(34);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:199: SEMI
			{
			DebugLocation(1, 199);
			mSEMI(); if (state.failed) return;

			}
			break;
		case 35:
			DebugEnterAlt(35);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:204: DOT
			{
			DebugLocation(1, 204);
			mDOT(); if (state.failed) return;

			}
			break;
		case 36:
			DebugEnterAlt(36);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:208: COMMA
			{
			DebugLocation(1, 208);
			mCOMMA(); if (state.failed) return;

			}
			break;
		case 37:
			DebugEnterAlt(37);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:214: ASSIGN
			{
			DebugLocation(1, 214);
			mASSIGN(); if (state.failed) return;

			}
			break;
		case 38:
			DebugEnterAlt(38);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:221: LPAREN
			{
			DebugLocation(1, 221);
			mLPAREN(); if (state.failed) return;

			}
			break;
		case 39:
			DebugEnterAlt(39);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:228: RPAREN
			{
			DebugLocation(1, 228);
			mRPAREN(); if (state.failed) return;

			}
			break;
		case 40:
			DebugEnterAlt(40);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:235: LCURLY
			{
			DebugLocation(1, 235);
			mLCURLY(); if (state.failed) return;

			}
			break;
		case 41:
			DebugEnterAlt(41);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:242: RCURLY
			{
			DebugLocation(1, 242);
			mRCURLY(); if (state.failed) return;

			}
			break;
		case 42:
			DebugEnterAlt(42);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:249: LBRACK
			{
			DebugLocation(1, 249);
			mLBRACK(); if (state.failed) return;

			}
			break;
		case 43:
			DebugEnterAlt(43);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:256: RBRACK
			{
			DebugLocation(1, 256);
			mRBRACK(); if (state.failed) return;

			}
			break;
		case 44:
			DebugEnterAlt(44);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:263: ID
			{
			DebugLocation(1, 263);
			mID(); if (state.failed) return;

			}
			break;
		case 45:
			DebugEnterAlt(45);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:266: INTEGER
			{
			DebugLocation(1, 266);
			mINTEGER(); if (state.failed) return;

			}
			break;
		case 46:
			DebugEnterAlt(46);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:274: FLOAT
			{
			DebugLocation(1, 274);
			mFLOAT(); if (state.failed) return;

			}
			break;
		case 47:
			DebugEnterAlt(47);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:280: WHITESPACE
			{
			DebugLocation(1, 280);
			mWHITESPACE(); if (state.failed) return;

			}
			break;
		case 48:
			DebugEnterAlt(48);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:291: LINE_COMMENT
			{
			DebugLocation(1, 291);
			mLINE_COMMENT(); if (state.failed) return;

			}
			break;
		case 49:
			DebugEnterAlt(49);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:1:304: BLOCK_COMMENT
			{
			DebugLocation(1, 304);
			mBLOCK_COMMENT(); if (state.failed) return;

			}
			break;

		}

	}

	partial void EnterRule_synpred1_MiniJava_fragment();
	partial void LeaveRule_synpred1_MiniJava_fragment();

	// $ANTLR start synpred1_MiniJava
	public void synpred1_MiniJava_fragment()
	{
		EnterRule_synpred1_MiniJava_fragment();
		EnterRule("synpred1_MiniJava_fragment", 56);
		TraceIn("synpred1_MiniJava_fragment", 56);
		try
		{
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:893:3: ( 'System.out.println' ~ ( 'a' .. 'z' | 'A' .. 'Z' | DIGIT ) )
			DebugEnterAlt(1);
			// D:\\University\\Конструирование компиляторов\\MiniJavaCompiler\\Project\\MiniJava.g:893:4: 'System.out.println' ~ ( 'a' .. 'z' | 'A' .. 'Z' | DIGIT )
			{
			DebugLocation(893, 4);
			Match("System.out.println"); if (state.failed) return;

			DebugLocation(893, 25);
			if ((input.LA(1)>='\u0000' && input.LA(1)<='/')||(input.LA(1)>=':' && input.LA(1)<='@')||(input.LA(1)>='[' && input.LA(1)<='`')||(input.LA(1)>='{' && input.LA(1)<='\uFFFF'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;}


			}

		}
		finally
		{
			TraceOut("synpred1_MiniJava_fragment", 56);
			LeaveRule("synpred1_MiniJava_fragment", 56);
			LeaveRule_synpred1_MiniJava_fragment();
		}
	}
	// $ANTLR end synpred1_MiniJava

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	DFA10 dfa10;
	DFA16 dfa16;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa10 = new DFA10(this);
		dfa16 = new DFA16(this);
	}

	private class DFA10 : DFA
	{
		private const string DFA10_eotS =
			"\x5\xFFFF";
		private const string DFA10_eofS =
			"\x5\xFFFF";
		private const string DFA10_minS =
			"\x2\x2E\x3\xFFFF";
		private const string DFA10_maxS =
			"\x1\x39\x1\x65\x3\xFFFF";
		private const string DFA10_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1\x1\x3";
		private const string DFA10_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA10_transitionS =
			{
				"\x1\x2\x1\xFFFF\xA\x1",
				"\x1\x3\x1\xFFFF\xA\x1\xB\xFFFF\x1\x4\x1F\xFFFF\x1\x4",
				"",
				"",
				""
			};

		private static readonly short[] DFA10_eot = DFA.UnpackEncodedString(DFA10_eotS);
		private static readonly short[] DFA10_eof = DFA.UnpackEncodedString(DFA10_eofS);
		private static readonly char[] DFA10_min = DFA.UnpackEncodedStringToUnsignedChars(DFA10_minS);
		private static readonly char[] DFA10_max = DFA.UnpackEncodedStringToUnsignedChars(DFA10_maxS);
		private static readonly short[] DFA10_accept = DFA.UnpackEncodedString(DFA10_acceptS);
		private static readonly short[] DFA10_special = DFA.UnpackEncodedString(DFA10_specialS);
		private static readonly short[][] DFA10_transition;

		static DFA10()
		{
			int numStates = DFA10_transitionS.Length;
			DFA10_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA10_transition[i] = DFA.UnpackEncodedString(DFA10_transitionS[i]);
			}
		}

		public DFA10( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 10;
			this.eot = DFA10_eot;
			this.eof = DFA10_eof;
			this.min = DFA10_min;
			this.max = DFA10_max;
			this.accept = DFA10_accept;
			this.special = DFA10_special;
			this.transition = DFA10_transition;
		}

		public override string Description { get { return "909:1: FLOAT : ( ( DIGIT )+ '.' ( DIGIT )* ( EXPONENT )? | '.' ( DIGIT )+ ( EXPONENT )? | ( DIGIT )+ EXPONENT );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA16 : DFA
	{
		private const string DFA16_eotS =
			"\x1\xFFFF\xF\x23\x3\xFFFF\x1\x3C\x1\x3E\x1\x40\x1\x42\x1\x44\x3\xFFFF"+
			"\x1\x45\x8\xFFFF\x1\x47\x1\xFFFF\x8\x23\x1\x50\xB\x23\xE\xFFFF\x7\x23"+
			"\x1\x63\x1\xFFFF\x5\x23\x1\x69\xA\x23\x1\x74\x1\x75\x1\xFFFF\x4\x23\x1"+
			"\x7A\x1\xFFFF\x1\x7B\x3\x23\x1\x7F\x1\x80\x4\x23\x2\xFFFF\x2\x23\x1\x87"+
			"\x1\x23\x2\xFFFF\x1\x89\x2\x23\x2\xFFFF\x1\x8C\x1\x8D\x1\x8E\x1\x23\x1"+
			"\x90\x1\x23\x1\xFFFF\x1\x92\x1\xFFFF\x1\x93\x1\x23\x3\xFFFF\x1\x95\x1"+
			"\xFFFF\x1\x96\x11\xFFFF";
		private const string DFA16_eofS =
			"\xA3\xFFFF";
		private const string DFA16_minS =
			"\x1\x9\x1\x6C\x1\x72\x1\x74\x1\x6C\x1\x6F\x1\x66\x2\x6F\x1\x68\x2\x65"+
			"\x1\x72\x1\x61\x1\x74\x1\x61\x3\xFFFF\x1\x2A\x4\x3D\x3\xFFFF\x1\x30\x8"+
			"\xFFFF\x1\x2E\x1\xFFFF\x1\x61\x1\x62\x1\x69\x1\x61\x1\x74\x1\x73\x1\x69"+
			"\x1\x74\x1\x30\x1\x75\x1\x6F\x1\x69\x1\x74\x1\x6C\x1\x77\x1\x75\x1\x6C"+
			"\x1\x72\x1\x73\x1\x69\xE\xFFFF\x1\x73\x1\x6C\x1\x6E\x1\x74\x2\x65\x1"+
			"\x64\x1\x30\x1\xFFFF\x1\x62\x2\x6C\x1\x75\x1\x6C\x1\x30\x1\x65\x1\x73"+
			"\x1\x69\x1\x74\x1\x6E\x1\x73\x1\x69\x1\x74\x1\x69\x1\x6E\x2\x30\x1\xFFFF"+
			"\x1\x6C\x2\x65\x1\x72\x1\x30\x1\xFFFF\x1\x30\x1\x65\x1\x6E\x1\x65\x2"+
			"\x30\x1\x63\x1\x66\x1\x63\x1\x64\x2\xFFFF\x1\x65\x1\x61\x1\x30\x1\x6E"+
			"\x2\xFFFF\x1\x30\x1\x67\x1\x6D\x2\xFFFF\x3\x30\x1\x73\x1\x30\x1\x6E\x1"+
			"\xFFFF\x1\x30\x1\xFFFF\x1\x30\x1\x2E\x3\xFFFF\x1\x30\x1\xFFFF\x1\x30"+
			"\x2\xFFFF\x1\x6F\x2\xFFFF\x1\x75\x1\x74\x1\x2E\x1\x70\x1\x72\x1\x69\x1"+
			"\x6E\x1\x74\x1\x6C\x1\x6E\x2\xFFFF";
		private const string DFA16_maxS =
			"\x1\x7D\x1\x6C\x1\x75\x1\x74\x1\x78\x1\x6F\x1\x6E\x2\x6F\x1\x68\x1\x65"+
			"\x1\x75\x1\x72\x1\x61\x1\x79\x1\x61\x3\xFFFF\x1\x2F\x4\x3D\x3\xFFFF\x1"+
			"\x39\x8\xFFFF\x1\x65\x1\xFFFF\x1\x61\x1\x62\x1\x69\x1\x61\x1\x74\x1\x73"+
			"\x1\x69\x1\x74\x1\x7A\x1\x75\x1\x6F\x1\x69\x1\x74\x1\x6C\x1\x77\x1\x75"+
			"\x1\x6C\x1\x72\x1\x73\x1\x69\xE\xFFFF\x1\x73\x1\x6C\x1\x6E\x1\x74\x2"+
			"\x65\x1\x64\x1\x7A\x1\xFFFF\x1\x62\x2\x6C\x1\x75\x1\x6C\x1\x7A\x1\x65"+
			"\x1\x73\x1\x69\x1\x74\x1\x6E\x1\x73\x1\x69\x1\x74\x1\x69\x1\x6E\x2\x7A"+
			"\x1\xFFFF\x1\x6C\x2\x65\x1\x72\x1\x7A\x1\xFFFF\x1\x7A\x1\x65\x1\x6E\x1"+
			"\x65\x2\x7A\x1\x63\x1\x66\x1\x63\x1\x64\x2\xFFFF\x1\x65\x1\x61\x1\x7A"+
			"\x1\x6E\x2\xFFFF\x1\x7A\x1\x67\x1\x6D\x2\xFFFF\x3\x7A\x1\x73\x1\x7A\x1"+
			"\x6E\x1\xFFFF\x1\x7A\x1\xFFFF\x1\x7A\x1\x2E\x3\xFFFF\x1\x7A\x1\xFFFF"+
			"\x1\x7A\x2\xFFFF\x1\x6F\x2\xFFFF\x1\x75\x1\x74\x1\x2E\x1\x70\x1\x72\x1"+
			"\x69\x1\x6E\x1\x74\x1\x6C\x1\x6E\x2\xFFFF";
		private const string DFA16_acceptS =
			"\x10\xFFFF\x1\x15\x1\x16\x1\x17\x5\xFFFF\x1\x1F\x1\x20\x1\x22\x1\xFFFF"+
			"\x1\x24\x1\x26\x1\x27\x1\x28\x1\x29\x1\x2A\x1\x2B\x1\x2C\x1\xFFFF\x1"+
			"\x2F\x14\xFFFF\x1\x30\x1\x31\x1\x18\x1\x1A\x1\x19\x1\x1B\x1\x1C\x1\x1D"+
			"\x1\x25\x1\x1E\x1\x21\x1\x23\x1\x2E\x1\x2D\x8\xFFFF\x1\x9\x12\xFFFF\x1"+
			"\x6\x5\xFFFF\x1\x10\xA\xFFFF\x1\xA\x1\x5\x4\xFFFF\x1\xD\x1\xE\x3\xFFFF"+
			"\x1\x12\x1\x1\x6\xFFFF\x1\xB\x1\xFFFF\x1\xF\x2\xFFFF\x1\x2\x1\x13\x1"+
			"\x3\x1\xFFFF\x1\x7\x1\xFFFF\x1\xC\x1\x11\x1\xFFFF\x1\x4\x1\x8\xA\xFFFF"+
			"\x2\x14";
		private const string DFA16_specialS =
			"\xA3\xFFFF}>";
		private static readonly string[] DFA16_transitionS =
			{
				"\x2\x25\x2\xFFFF\x1\x25\x12\xFFFF\x1\x25\x1\x17\x4\xFFFF\x1\x18\x1\xFFFF"+
				"\x1\x1D\x1\x1E\x1\x12\x1\x10\x1\x1C\x1\x11\x1\x1B\x1\x13\xA\x24\x1\xFFFF"+
				"\x1\x1A\x1\x14\x1\x16\x1\x15\x2\xFFFF\x12\x23\x1\xE\x7\x23\x1\x21\x1"+
				"\xFFFF\x1\x22\x1\xFFFF\x1\x23\x1\xFFFF\x1\x23\x1\x8\x1\x1\x1\x7\x1\x4"+
				"\x1\xD\x2\x23\x1\x6\x3\x23\x1\xF\x1\xB\x1\x23\x1\x2\x1\x23\x1\xA\x1"+
				"\x3\x1\xC\x1\x23\x1\x5\x1\x9\x3\x23\x1\x1F\x1\x19\x1\x20",
				"\x1\x26",
				"\x1\x28\x2\xFFFF\x1\x27",
				"\x1\x29",
				"\x1\x2B\xB\xFFFF\x1\x2A",
				"\x1\x2C",
				"\x1\x2E\x7\xFFFF\x1\x2D",
				"\x1\x2F",
				"\x1\x30",
				"\x1\x31",
				"\x1\x32",
				"\x1\x34\xF\xFFFF\x1\x33",
				"\x1\x35",
				"\x1\x36",
				"\x1\x37\x4\xFFFF\x1\x38",
				"\x1\x39",
				"",
				"",
				"",
				"\x1\x3B\x4\xFFFF\x1\x3A",
				"\x1\x3D",
				"\x1\x3F",
				"\x1\x41",
				"\x1\x43",
				"",
				"",
				"",
				"\xA\x46",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x46\x1\xFFFF\xA\x24\xB\xFFFF\x1\x46\x1F\xFFFF\x1\x46",
				"",
				"\x1\x48",
				"\x1\x49",
				"\x1\x4A",
				"\x1\x4B",
				"\x1\x4C",
				"\x1\x4D",
				"\x1\x4E",
				"\x1\x4F",
				"\xA\x23\x7\xFFFF\x1A\x23\x4\xFFFF\x1\x23\x1\xFFFF\x1A\x23",
				"\x1\x51",
				"\x1\x52",
				"\x1\x53",
				"\x1\x54",
				"\x1\x55",
				"\x1\x56",
				"\x1\x57",
				"\x1\x58",
				"\x1\x59",
				"\x1\x5A",
				"\x1\x5B",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x5C",
				"\x1\x5D",
				"\x1\x5E",
				"\x1\x5F",
				"\x1\x60",
				"\x1\x61",
				"\x1\x62",
				"\xA\x23\x7\xFFFF\x1A\x23\x4\xFFFF\x1\x23\x1\xFFFF\x1A\x23",
				"",
				"\x1\x64",
				"\x1\x65",
				"\x1\x66",
				"\x1\x67",
				"\x1\x68",
				"\xA\x23\x7\xFFFF\x1A\x23\x4\xFFFF\x1\x23\x1\xFFFF\x1A\x23",
				"\x1\x6A",
				"\x1\x6B",
				"\x1\x6C",
				"\x1\x6D",
				"\x1\x6E",
				"\x1\x6F",
				"\x1\x70",
				"\x1\x71",
				"\x1\x72",
				"\x1\x73",
				"\xA\x23\x7\xFFFF\x1A\x23\x4\xFFFF\x1\x23\x1\xFFFF\x1A\x23",
				"\xA\x23\x7\xFFFF\x1A\x23\x4\xFFFF\x1\x23\x1\xFFFF\x1A\x23",
				"",
				"\x1\x76",
				"\x1\x77",
				"\x1\x78",
				"\x1\x79",
				"\xA\x23\x7\xFFFF\x1A\x23\x4\xFFFF\x1\x23\x1\xFFFF\x1A\x23",
				"",
				"\xA\x23\x7\xFFFF\x1A\x23\x4\xFFFF\x1\x23\x1\xFFFF\x1A\x23",
				"\x1\x7C",
				"\x1\x7D",
				"\x1\x7E",
				"\xA\x23\x7\xFFFF\x1A\x23\x4\xFFFF\x1\x23\x1\xFFFF\x1A\x23",
				"\xA\x23\x7\xFFFF\x1A\x23\x4\xFFFF\x1\x23\x1\xFFFF\x1A\x23",
				"\x1\x81",
				"\x1\x82",
				"\x1\x83",
				"\x1\x84",
				"",
				"",
				"\x1\x85",
				"\x1\x86",
				"\xA\x23\x7\xFFFF\x1A\x23\x4\xFFFF\x1\x23\x1\xFFFF\x1A\x23",
				"\x1\x88",
				"",
				"",
				"\xA\x23\x7\xFFFF\x1A\x23\x4\xFFFF\x1\x23\x1\xFFFF\x1A\x23",
				"\x1\x8A",
				"\x1\x8B",
				"",
				"",
				"\xA\x23\x7\xFFFF\x1A\x23\x4\xFFFF\x1\x23\x1\xFFFF\x1A\x23",
				"\xA\x23\x7\xFFFF\x1A\x23\x4\xFFFF\x1\x23\x1\xFFFF\x1A\x23",
				"\xA\x23\x7\xFFFF\x1A\x23\x4\xFFFF\x1\x23\x1\xFFFF\x1A\x23",
				"\x1\x8F",
				"\xA\x23\x7\xFFFF\x1A\x23\x4\xFFFF\x1\x23\x1\xFFFF\x1A\x23",
				"\x1\x91",
				"",
				"\xA\x23\x7\xFFFF\x1A\x23\x4\xFFFF\x1\x23\x1\xFFFF\x1A\x23",
				"",
				"\xA\x23\x7\xFFFF\x1A\x23\x4\xFFFF\x1\x23\x1\xFFFF\x1A\x23",
				"\x1\x94",
				"",
				"",
				"",
				"\xA\x23\x7\xFFFF\x1A\x23\x4\xFFFF\x1\x23\x1\xFFFF\x1A\x23",
				"",
				"\xA\x23\x7\xFFFF\x1A\x23\x4\xFFFF\x1\x23\x1\xFFFF\x1A\x23",
				"",
				"",
				"\x1\x97",
				"",
				"",
				"\x1\x98",
				"\x1\x99",
				"\x1\x9A",
				"\x1\x9B",
				"\x1\x9C",
				"\x1\x9D",
				"\x1\x9E",
				"\x1\x9F",
				"\x1\xA0",
				"\x1\xA1",
				"",
				""
			};

		private static readonly short[] DFA16_eot = DFA.UnpackEncodedString(DFA16_eotS);
		private static readonly short[] DFA16_eof = DFA.UnpackEncodedString(DFA16_eofS);
		private static readonly char[] DFA16_min = DFA.UnpackEncodedStringToUnsignedChars(DFA16_minS);
		private static readonly char[] DFA16_max = DFA.UnpackEncodedStringToUnsignedChars(DFA16_maxS);
		private static readonly short[] DFA16_accept = DFA.UnpackEncodedString(DFA16_acceptS);
		private static readonly short[] DFA16_special = DFA.UnpackEncodedString(DFA16_specialS);
		private static readonly short[][] DFA16_transition;

		static DFA16()
		{
			int numStates = DFA16_transitionS.Length;
			DFA16_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA16_transition[i] = DFA.UnpackEncodedString(DFA16_transitionS[i]);
			}
		}

		public DFA16( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 16;
			this.eot = DFA16_eot;
			this.eof = DFA16_eof;
			this.min = DFA16_min;
			this.max = DFA16_max;
			this.accept = DFA16_accept;
			this.special = DFA16_special;
			this.transition = DFA16_transition;
		}

		public override string Description { get { return "1:1: Tokens : ( CLASS | PUBLIC | STATIC | EXTENDS | VOID | INT | DOUBLE | BOOLEAN | IF | ELSE | WHILE | RETURN | NULL | TRUE | FALSE | NEW | STRING | MAIN | PRINT | PRINT2 | PLUS | MINUS | STAR | DIV | LESS | LESSEQ | MOREEQ | MORE | EQUAL | NEQUAL | LAND | LOR | LNOT | SEMI | DOT | COMMA | ASSIGN | LPAREN | RPAREN | LCURLY | RCURLY | LBRACK | RBRACK | ID | INTEGER | FLOAT | WHITESPACE | LINE_COMMENT | BLOCK_COMMENT );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

 
	#endregion

}

} // namespace  MiniJavaSyntax 
